<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Channel.js.html":{"id":"Channel.js.html","title":"Source: Channel.js","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Source: Channel.js /** * Channel interface. * [RTCDataChannel]{@link https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel} * and * [WebSocket]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebSocket} * implement it implicitly. Any other channel must implement this interface. * * @interface */ class Channel { constructor (channel, webChannel, peerId) { channel.binaryType = 'arraybuffer' this.channel = channel this.webChannel = webChannel this.peerId = peerId } config () { this.channel.onmessage = (msgEvt) =&gt; { this.webChannel.onChannelMessage(this, msgEvt.data) } this.channel.onerror = (evt) =&gt; { this.webChannel.onChannelError(evt) } this.channel.onclose = (evt) =&gt; { this.webChannel.onChannelClose(evt) } } /** * send - description. * * @abstract * @param {string} msg - Message in stringified JSON format. */ send (data) { if (this.channel.readyState !== 'closed') { this.channel.send(data) } } /** * Close channel. * * @abstract */ close () { this.channel.close() } } export default Channel × Search results Close "},"JoiningPeer.js.html":{"id":"JoiningPeer.js.html","title":"Source: JoiningPeer.js","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Source: JoiningPeer.js /** * This class represents a temporary state of a peer, while he is about to join * the web channel. During the joining process every peer in the web channel * and the joining peer have an instance of this class with the same `id` and * `intermediaryId` attribute values. After the joining process has been finished * regardless of success, these instances will be deleted. */ class JoiningPeer { constructor (id, intermediaryId, intermediaryChannel) { /** * The joining peer id. * * @type {string} */ this.id = id /** * The id of the peer who invited the joining peer to the web channel. It is * a member of the web channel and called an intermediary peer between the * joining peer and the web channel. The same value for all instances. * * @type {string} */ this.intermediaryId = intermediaryId /** * The channel between the joining peer and intermediary peer. It is null * for every peer, but the joining and intermediary peers. * * @type {Channel} */ this.intermediaryChannel = intermediaryChannel /** * This attribute is proper to each peer. Array of channels which will be * added to the current peer once the joining peer become the member of the * web channel. * * @type {Channel[]} */ this.channelsToAdd = [] /** * This attribute is proper to each peer. Array of channels which will be * closed with the current peer once the joining peer become the member of the * web channel. * * @type {Channel[]} */ this.channelsToRemove = [] } /** * Add channel to `channelsToAdd` array. * * @param {Channel} channel - Channel to add. */ toAddList (channel) { this.channelsToAdd[this.channelsToAdd.length] = channel } /** * Add channel to `channelsToRemove` array * * @param {Channel} channel - Channel to add. */ toRemoveList (channel) { this.channelsToAdd[this.channelsToAdd.length] = channel } } export default JoiningPeer × Search results Close "},"WebChannel.js.html":{"id":"WebChannel.js.html","title":"Source: WebChannel.js","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Source: WebChannel.js import {provide, FULLY_CONNECTED, WEBRTC, MESSAGE_BUILDER} from './serviceProvider' import Channel from './Channel' import JoiningPeer from './JoiningPeer' const msgBuilder = provide(MESSAGE_BUILDER) const MAX_ID = 4294967295 const PING_TIMEOUT = 5000 /** * One of the internal message type. It's a peer message. * @type {int} */ const USER_DATA = 1 /** * One of the internal message type. This message should be threated by a * specific service class * @type {int} */ const SERVICE_DATA = 2 /** * One of the internal message type. Means a peer has left the WebChannel. * @type {int} */ const LEAVE = 3 /** * One of the internal message type. Initialization message for the joining peer. * @type {int} */ const JOIN_INIT = 4 /** * One of the internal message type. The message is intended for the WebChannel * members to notify them about the joining peer. * @type {int} */ const JOIN_NEW_MEMBER = 5 /** * One of the internal message type. The message is intended for the WebChannel * members to notify them that the joining peer has not succeed. * @type {int} */ const REMOVE_NEW_MEMBER = 6 /** * Constant used to build a message to be sent to a newly joining peer that he * has can now succesfully join Web Channel. * @type {int} */ const JOIN_FINILIZE = 7 /** * Constant used to build a message to be sent by the newly joining peer to all * peers in Web Channel to notify them that he has succesfully joined the Web * Channel. * @type {int} */ const JOIN_SUCCESS = 8 /** * @type {int} */ const INIT_CHANNEL_PONG = 10 /** * @type {int} */ const PING = 11 /** * @type {int} */ const PONG = 12 class WebChannelGate { constructor (action) { this.door = null this.accessData = null this.action = action } getAccessData () { return this.accessData } isOpen () { return this.door !== null } setOpen (door, accessData, action) { this.door = door this.door.onclose = this.action this.accessData = accessData } close () { if (this.isOpen()) { this.door.close() this.door = null } } } /** * This class is an API starting point. It represents a group of collaborators * also called peers. Each peer can send/receive broadcast as well as personal * messages. Every peer in the `WebChannel` can invite another person to join * the *WebChannel* and he also possess enough information to be able to add it * preserving the current *WebChannel* structure (network topology). */ class WebChannel { /** * When the `WebChannel` is open, any clients should you this data to join * the `WebChannel`. * * @typedef {Object} WebChannel~AccessData * @property {string} key - The key to join the `WebChannel` * @property {string} url - Signaling server URL to use to join the `WebChannel` */ /** * `WebChannel` constructor. `WebChannel` can be parameterized in terms of * network topology and connector technology (WebRTC or WebSocket. Currently * WebRTC is only available). * * @param {Object} [options] `WebChannel` configuration. * @param {string} [options.topology=FULLY_CONNECTED] Defines the network * topology. * @param {string} [options.connector=WEBRTC] Determines the connection * technology to use for build `WebChannel`. * @return {WebChannel} Empty `WebChannel` without any connection. */ constructor (options = {}) { this.defaults = { connector: WEBRTC, topology: FULLY_CONNECTED } this.settings = Object.assign({}, this.defaults, options) /** * Channels through which this peer is connected with other peers. This * attribute depends on the `WebChannel` topology. E. g. in fully connected * `WebChannel` you are connected to each other peer in the group, however * in the star structure this attribute contains only the connection to * the central peer. * * @private */ this.channels = new Set() /** * This event handler is used to resolve *Promise* in `WebChannel.join`. * * @private */ this.onJoin /** @private */ this.joiningPeers = new Set() /** @private */ this.connectWithRequests = new Map() this.topology = this.settings.topology /** @private */ this.peerNb = 0 /** @private */ this.pingTime = 0 /** @private */ this.gate = new WebChannelGate((closeEvt) =&gt; this.onClose(closeEvt)) /** * Unique identifier of this `WebChannel`. The same for all peers. * @readonly */ this.id = this.generateId() /** * Unique peer identifier of you in this `WebChannel`. After each `join` function call * this id will change, because it is up to the `WebChannel` to assign it when * you join. * * @readonly */ this.myId = this.generateId() /** * Is the event handler called when a new peer has joined the `WebChannel`. * * @param {number} id - Id of the joined peer */ this.onJoining = (id) =&gt; {} /** * Is the event handler called when a message is available on the `WebChannel`. * * @param {number} id - Id of the peer who sent this message * @param {string|external:ArrayBufferView} data - Message * @param {boolean} isBroadcast - It is true if the message is sent via * [send]{@link WebChannel#send} method and false if it is sent via * [sendTo]{@link WebChannel#sendTo} method */ this.onMessage = (id, msg, isBroadcast) =&gt; {} /** * Is the event handler called when a peer hes left the `WebChannel`. * * @param {number} id - Id of the peer who has left */ this.onLeaving = (id) =&gt; {} /** * Is the event handler called when the `WebChannel` has been closed. * * @param {external:CloseEvent} id - Close event object */ this.onClose = (closeEvt) =&gt; {} } /** * Enable other peers to join the `WebChannel` with your help as an * intermediary peer. * * @param {Object} [options] Any available connection service options * @return {PromiseWebChannel~AccessData} It is resolved once the `WebChannel` * is open. The callback function take a parameter of type {@link WebChannel~AccessData}. */ openForJoining (options = {}) { let settings = Object.assign({}, this.settings, options) let cBuilder = provide(settings.connector, settings) return cBuilder.open(this.generateKey(), (channel) =&gt; { this.initChannel(channel, false) .then((channel) =&gt; { // console.log('INITIATOR is adding: ' + channel.peerId) let jp = this.addJoiningPeer(channel.peerId, this.myId, channel) this.manager.broadcast(this, msgBuilder.msg( JOIN_NEW_MEMBER, {id: channel.peerId, intermediaryId: this.myId}) ) channel.send(msgBuilder.msg(JOIN_INIT, { manager: this.settings.topology, id: channel.peerId, intermediaryId: this.myId}) ) this.manager.add(channel) .then(() =&gt; channel.send(msgBuilder.msg(JOIN_FINILIZE))) .catch((msg) =&gt; { this.manager.broadcast(this, msgBuilder( REMOVE_NEW_MEMBER, {id: channel.peerId}) ) this.removeJoiningPeer(jp.id) }) }) }).then((data) =&gt; { let accessData = {key: data.key, url: data.url} this.gate.setOpen(data.socket, accessData) return accessData }) } /** * Prevent clients to join the `WebChannel` even if they possesses a key. */ closeForJoining () { this.gate.close() } /** * If the `WebChannel` is open, the clients can join it through you, otherwise * it is not possible. * * @returns {boolean} True if the `WebChannel` is open, false otherwise */ isOpen () { return this.gate.isOpen() } /** * Join the `WebChannel`. * * @param {string} key - The key provided by one of the `WebChannel` members. * @param {type} [options] - Any available connection service options. * @return {Promise} It resolves once you became a `WebChannel` member. */ join (key, options = {}) { let settings = Object.assign({}, this.settings, options) let cBuilder = provide(settings.connector, settings) return new Promise((resolve, reject) =&gt; { this.onJoin = () =&gt; resolve(this) cBuilder.join(key) .then((channel) =&gt; this.initChannel(channel, true)) .catch(reject) }) } /** * Leave the `WebChannel`. No longer can receive and send messages to the group. * */ leave () { if (this.channels.size !== 0) { this.manager.broadcast(this, msgBuilder.msg(LEAVE, {id: this.myId})) this.topology = this.settings.topology this.channels.forEach((c) =&gt; { c.close() }) this.channels.clear() this.gate.close() } } /** * Send the message to all `WebChannel` members. * * @param {string|external:ArrayBufferView} data - Message */ send (data) { if (this.channels.size !== 0) { msgBuilder.handleUserMessage(data, this.myId, null, (dataChunk) =&gt; { this.manager.broadcast(this, dataChunk) }) } } /** * Send the message to a particular peer in the `WebChannel`. * * @param {number} id - Id of the recipient peer * @param {string|external:ArrayBufferView} data - Message */ sendTo (id, data) { if (this.channels.size !== 0) { msgBuilder.handleUserMessage(data, this.myId, id, (dataChunk) =&gt; { this.manager.sendTo(id, this, dataChunk) }, false) } } /** * Get the data which should be provided to all clients who must join * the `WebChannel`. It is the same data which * {@link WebChannel#openForJoining} callback function provides. * * @returns {WebChannel~AccessData|null} - Data to join the `WebChannel` * or null is the `WebChannel` is closed */ getAccess () { return this.gate.getAccessData() } /** * Get the ping of the `WebChannel`. It is an amount in milliseconds which * corresponds to the longest ping to each `WebChannel` member. * * @returns {Promise} */ ping () { return new Promise((resolve, reject) =&gt; { if (this.pingTime === 0) { this.pingTime = Date.now() this.maxTime = 0 this.pongNb = 0 this.pingFinish = (delay) =&gt; { resolve(delay) } this.manager.broadcast(this, msgBuilder.msg(PING, {senderId: this.myId})) setTimeout(() =&gt; { resolve(PING_TIMEOUT) }, PING_TIMEOUT) } }) } /** * // TODO: add doc * */ get topology () { return this.settings.topology } /** * Send a message to a service of the same peer, joining peer or any peer in * the Web Channel). * * @private * @param {string} serviceName - Service name. * @param {string} recepient - Identifier of recepient peer id. * @param {Object} [msg={}] - Message to send. */ sendSrvMsg (serviceName, recepient, msg = {}, channel = null) { let fullMsg = msgBuilder.msg( SERVICE_DATA, {serviceName, recepient, data: Object.assign({}, msg)} ) if (channel !== null) { channel.send(fullMsg) return } if (recepient === this.myId) { this.onChannelMessage(null, fullMsg) } else { // If this function caller is a peer who is joining if (this.isJoining()) { this.getJoiningPeer(this.myId) .intermediaryChannel .send(fullMsg) } else { // If the recepient is a joining peer if (this.hasJoiningPeer(recepient)) { let jp = this.getJoiningPeer(recepient) // If I am an intermediary peer for recepient if (jp.intermediaryId === this.myId) { jp.intermediaryChannel.send(fullMsg) // If not, then send this message to the recepient's intermediary peer } else { this.manager.sendTo(jp.intermediaryId, this, fullMsg) } // If the recepient is a member of webChannel } else { this.manager.sendTo(recepient, this, fullMsg) } } } } /** * // TODO: add doc * * @private */ onChannelMessage (channel, data) { let header = msgBuilder.readHeader(data) if (header.code === USER_DATA) { msgBuilder.readUserMessage(this.id, header.senderId, data, (fullData, isBroadcast) =&gt; { this.onMessage(header.senderId, fullData, isBroadcast) }) } else { let msg = msgBuilder.readInternalMessage(data) switch (header.code) { case LEAVE: for (let c of this.channels) { if (c.peerId === msg.id) { c.close() this.channels.delete(c) } } this.peerNb-- this.onLeaving(msg.id) break case SERVICE_DATA: if (this.myId === msg.recepient) { provide(msg.serviceName, this.settings).onMessage(this, channel, msg.data) } else { this.sendSrvMsg(msg.serviceName, msg.recepient, msg.data) } break case JOIN_INIT: this.topology = msg.manager this.myId = msg.id channel.peerId = msg.intermediaryId this.addJoiningPeer(msg.id, msg.intermediaryId, channel) break case JOIN_NEW_MEMBER: this.addJoiningPeer(msg.id, msg.intermediaryId) break case REMOVE_NEW_MEMBER: this.removeJoiningPeer(msg.id) break case JOIN_FINILIZE: this.joinSuccess(this.myId) // console.log(this.myId + ' JOINED SUCCESSFULLY') this.manager.broadcast(this, msgBuilder.msg(JOIN_SUCCESS, {id: this.myId})) this.onJoin() break case JOIN_SUCCESS: // console.log(this.myId + ' JOIN_SUCCESS from ' + msg.id) this.joinSuccess(msg.id) this.peerNb++ this.onJoining(msg.id) break case INIT_CHANNEL_PONG: channel.onPong() delete channel.onPong break case PING: this.manager.sendTo(msg.senderId, this, msgBuilder.msg(PONG)) break case PONG: let now = Date.now() this.pongNb++ this.maxTime = Math.max(this.maxTime, now - this.pingTime) if (this.pongNb === this.peerNb) { this.pingFinish(this.maxTime) this.pingTime = 0 } break } } } /** * // TODO: add doc * * @private */ onChannelError (evt) { console.log('DATA_CHANNEL ERROR: ', evt) } /** * // TODO: add doc * * @private */ onChannelClose (evt) { console.log('DATA_CHANNEL CLOSE: ', evt) } /** * // TODO: add doc * * @private */ set topology (name) { this.settings.topology = name this.manager = provide(this.settings.topology) } /** * // TODO: add doc * * @private */ initChannel (ch, isInitiator, id = -1) { return new Promise((resolve, reject) =&gt; { if (id === -1) { id = this.generateId() } let channel = new Channel(ch, this, id) // TODO: treat the case when the 'ping' or 'pong' message has not been received if (isInitiator) { channel.config() channel.onPong = () =&gt; resolve(channel) ch.send('ping') } else { ch.onmessage = (msgEvt) =&gt; { if (msgEvt.data === 'ping') { channel.config() channel.send(msgBuilder.msg(INIT_CHANNEL_PONG)) resolve(channel) } } } }) } /** * joinSuccess - description * * @private * @param {type} id description * @return {type} description */ joinSuccess (id) { let jp = this.getJoiningPeer(id) jp.channelsToAdd.forEach((c) =&gt; { this.channels.add(c) }) // TODO: handle channels which should be closed &amp; removed // this.joiningPeers.delete(jp) } /** * TODO: add doc * * @private * @param {type} id description */ getJoiningPeer (id) { // if (this.myId !== id) { // console.log('Me ' + this.myId + ' is looking for ' + id) // } for (let jp of this.joiningPeers) { if (jp.id === id) { return jp } } throw new Error('Peer ' + this.myId + ' could not find the joining peer ' + id) } /** * TODO: add doc * * @private */ getJoiningPeers () { return this.joiningPeers } /** * TODO: add doc * * @private * @param {type} jp description * @return {type} description */ addJoiningPeer (peerId, intermediaryId, intermediaryChannel = null) { // if (this.myId !== peerId) { // console.log('Me ' + this.myId + ' is adding: ' + peerId + ' where intermediaryId is ' + intermediaryId + ' and the channel is ' + (intermediaryChannel !== null)) // } let jp = new JoiningPeer(peerId, intermediaryId, intermediaryChannel) if (this.hasJoiningPeer(peerId)) { throw new Error('Joining peer already exists!') } this.joiningPeers.add(jp) return jp } /** * TODO: add doc * * @private * @param {type} id description * @return {type} description */ removeJoiningPeer (id) { if (this.hasJoiningPeer(id)) { this.joiningPeers.delete(this.getJoiningPeer(id)) } } /** * TODO: add doc * * @private * @return {type} description */ isJoining () { for (let jp of this.joiningPeers) { if (jp.id === this.myId) { return true } } return false } /** * TODO: add doc * * @private * @param {type} id description * @return {type} description */ hasJoiningPeer (id) { for (let jp of this.joiningPeers) { if (jp.id === id) { return true } } return false } /** * TODO: add doc * * @private * @return {type} description */ generateKey () { const MIN_LENGTH = 5 const DELTA_LENGTH = 0 const MASK = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' let result = '' const length = MIN_LENGTH + Math.round(Math.random() * DELTA_LENGTH) for (let i = 0; i &lt; length; i++) { result += MASK[Math.round(Math.random() * (MASK.length - 1))] } return result } /** * TODO: add doc * * @private * @return {type} description */ generateId () { let id do { id = Math.ceil(Math.random() * MAX_ID) for (let c of this.channels) { if (id === c.peerId) continue } if (this.hasJoiningPeer(id)) continue if (id === this.myId) continue break } while (true) return id } } export {WebChannel, USER_DATA} × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Source: index.js import '../node_modules/webrtc-adapter/out/adapter_no_edge_no_global_es5' export { WEBRTC, FULLY_CONNECTED } from './serviceProvider' export { WebChannel } from './WebChannel' /** * @external JSON * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON} */ /** * @external Error * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Error} */ /** * @external RTCPeerConnection * @see {@link https://developer.mozilla.org/en/docs/Web/API/RTCPeerConnection} */ /** * @external RTCSessionDescription * @see {@link https://developer.mozilla.org/en/docs/Web/API/RTCSessionDescription} */ /** * @external RTCDataChannel * @see {@link https://developer.mozilla.org/en/docs/Web/API/RTCDataChannel} */ /** * @external RTCIceCandidate * @see {@link https://developer.mozilla.org/en/docs/Web/API/RTCIceCandidate} */ /** * @external RTCPeerConnectionIceEvent * @see {@link https://developer.mozilla.org/en/docs/Web/API/RTCPeerConnectionIceEvent} */ /** * @external CloseEvent * @see {@link https://developer.mozilla.org/en/docs/Web/API/CloseEvent/CloseEvent} */ /** * @external ArrayBufferView * @see {@link https://developer.mozilla.org/en/docs/Web/API/ArrayBufferView} */ × Search results Close "},"service_channelBuilder_WebRTCService.js.html":{"id":"service_channelBuilder_WebRTCService.js.html","title":"Source: service/channelBuilder/WebRTCService.js","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Source: service/channelBuilder/WebRTCService.js import {ChannelBuilderInterface} from './channelBuilder' /** * Ice candidate event handler. * * @callback WebRTCService~onCandidate * @param {external:RTCPeerConnectionIceEvent} evt - Event. */ /** * Session description event handler. * * @callback WebRTCService~onSDP * @param {external:RTCPeerConnectionIceEvent} evt - Event. */ /** * Data channel event handler. * * @callback WebRTCService~onChannel * @param {external:RTCPeerConnectionIceEvent} evt - Event. */ /** * The goal of this class is to prevent the error when adding an ice candidate * before the remote description has been set. */ class RTCPendingConnections { constructor () { this.connections = new Map() } /** * Prepares pending connection for the specified peer only if it has not been added already. * * @param {string} id - Peer id */ add (id) { if (!this.connections.has(id)) { let pc = null let obj = {promise: null} obj.promise = new Promise((resolve, reject) =&gt; { Object.defineProperty(obj, 'pc', { get: () =&gt; pc, set: (value) =&gt; { pc = value resolve() } }) setTimeout(reject, CONNECT_TIMEOUT, 'timeout') }) this.connections.set(id, obj) } } /** * Remove a pending connection from the Map. Usually when the connection has already * been established and there is now interest to hold this reference. * * @param {string} id - Peer id. */ remove (id) { this.connections.delete(id) } /** * Returns RTCPeerConnection object for the provided peer id. * * @param {string} id - Peer id. * @return {external:RTCPeerConnection} - Peer connection. */ getPC (id) { return this.connections.get(id).pc } /** * Updates RTCPeerConnection reference for the provided peer id. * * @param {string} id - Peer id. * @param {external:RTCPeerConnection} pc - Peer connection. */ setPC (id, pc) { this.connections.get(id).pc = pc } /** * When the remote description is set, it will add the ice candidate to the * peer connection of specified peer. * * @param {string} id - Peer id. * @param {external:RTCIceCandidate} candidate - Ice candidate. * @return {Promise} - Resolved once the ice candidate has been succesfully added. */ addIceCandidate (id, candidate) { let obj = this.connections.get(id) return obj.promise.then(() =&gt; { return obj.pc.addIceCandidate(candidate) }) } } const CONNECT_TIMEOUT = 2000 const connectionsByWC = new Map() /** * Service class responsible to establish connections between peers via * `RTCDataChannel`. * * @see {@link external:RTCPeerConnection} * @extends module:channelBuilder~Interface */ class WebRTCService extends ChannelBuilderInterface { /** * WebRTCService constructor. * * @param {Object} [options] - This service options. * @param {Object} [options.signaling='wws://sigver-coastteam.rhcloud.com:8000'] - * Signaling server URL. * @param {Object[]} [options.iceServers=[{urls: 'stun:23.21.150.121'},{urls: 'stun:stun.l.google.com:19302'},{urls: 'turn:numb.viagenie.ca', credential: 'webrtcdemo', username: 'louis%40mozilla.com'}]] - WebRTC options to setup which STUN * and TURN servers to be used. */ constructor (options = {}) { super() this.defaults = { signaling: 'wws://sigver-coastteam.rhcloud.com:8000', iceServers: [ {urls: 'stun:23.21.150.121'}, {urls: 'stun:stun.l.google.com:19302'}, {urls: 'turn:numb.viagenie.ca', credential: 'webrtcdemo', username: 'louis%40mozilla.com'} ] } this.settings = Object.assign({}, this.defaults, options) } open (key, onChannel, options = {}) { let settings = Object.assign({}, this.settings, options) return new Promise((resolve, reject) =&gt; { let connections = new RTCPendingConnections() let socket try { socket = new window.WebSocket(settings.signaling) } catch (err) { reject(err.message) } // Send a message to signaling server: ready to receive offer socket.onopen = () =&gt; { try { socket.send(JSON.stringify({key})) } catch (err) { reject(err.message) } // TODO: find a better solution than setTimeout. This is for the case when the key already exists and thus the server will close the socket, but it will close it after this function resolves the Promise. setTimeout(resolve, 100, {key, url: settings.signaling, socket}) } socket.onmessage = (evt) =&gt; { let msg = JSON.parse(evt.data) if (!('id' in msg) || !('data' in msg)) { console.log('Unknown message from the signaling server: ' + evt.data) socket.close() return } connections.add(msg.id) if ('offer' in msg.data) { this.createPeerConnectionAndAnswer( (candidate) =&gt; socket.send(JSON.stringify({id: msg.id, data: {candidate}})), (answer) =&gt; socket.send(JSON.stringify({id: msg.id, data: {answer}})), onChannel, msg.data.offer ).then((pc) =&gt; connections.setPC(msg.id, pc)) .catch((reason) =&gt; { console.error(`Answer generation failed: ${reason}`) }) } else if ('candidate' in msg.data) { connections.addIceCandidate( msg.id, this.createIceCandidate(msg.data.candidate) ).catch((reason) =&gt; { console.error(`Adding ice candidate failed: ${reason}`) }) } } socket.onclose = (closeEvt) =&gt; { if (closeEvt.code !== 1000) { console.error(`Socket with signaling server ${settings.signaling} has been closed with code ${closeEvt.code}: ${closeEvt.reason}`) reject(closeEvt.reason) } } }) } join (key, options = {}) { let settings = Object.assign({}, this.settings, options) return new Promise((resolve, reject) =&gt; { let pc // Connect to the signaling server let socket = new WebSocket(settings.signaling) socket.onopen = () =&gt; { // Prepare and send offer this.createPeerConnectionAndOffer( (candidate) =&gt; socket.send(JSON.stringify({data: {candidate}})), (offer) =&gt; socket.send(JSON.stringify({join: key, data: {offer}})), resolve ) .then((peerConnection) =&gt; { pc = peerConnection }) .catch(reject) } socket.onmessage = (evt) =&gt; { try { let msg = JSON.parse(evt.data) // Check message format if (!('data' in msg)) { reject(`Unknown message from the signaling server: ${evt.data}`) } if ('answer' in msg.data) { pc.setRemoteDescription(this.createSessionDescription(msg.data.answer)) .catch(reject) } else if ('candidate' in msg.data) { pc.addIceCandidate(this.createIceCandidate(msg.data.candidate)) .catch((evt) =&gt; { // This exception does not reject the current Promise, because // still the connection may be established even without one or // several candidates console.error('Adding candidate failed: ', evt) }) } else { reject(`Unknown message from the signaling server: ${evt.data}`) } } catch (err) { reject(err.message) } } socket.onerror = (evt) =&gt; { reject('WebSocket with signaling server error') } socket.onclose = (closeEvt) =&gt; { if (closeEvt.code !== 1000) { reject(`Socket with signaling server ${settings.signaling} has been closed with code ${closeEvt.code}: ${closeEvt.reason}`) } } }) } connectMeTo (wc, id) { return new Promise((resolve, reject) =&gt; { let sender = wc.myId let connections = this.getPendingConnections(wc) connections.add(id) this.createPeerConnectionAndOffer( (candidate) =&gt; wc.sendSrvMsg(this.name, id, {sender, candidate}), (offer) =&gt; wc.sendSrvMsg(this.name, id, {sender, offer}), (channel) =&gt; { connections.remove(id) resolve(channel) } ).then((pc) =&gt; connections.setPC(id, pc)) setTimeout(reject, CONNECT_TIMEOUT, 'Timeout') }) } onMessage (wc, channel, msg) { let connections = this.getPendingConnections(wc) connections.add(msg.sender) if ('offer' in msg) { this.createPeerConnectionAndAnswer( (candidate) =&gt; wc.sendSrvMsg(this.name, msg.sender, {sender: wc.myId, candidate}), (answer) =&gt; wc.sendSrvMsg(this.name, msg.sender, {sender: wc.myId, answer}), (channel) =&gt; { wc.initChannel(channel, false, msg.sender) connections.remove(channel.peerId) }, msg.offer ).then((pc) =&gt; { connections.setPC(msg.sender, pc) }) } if ('answer' in msg) { connections.getPC(msg.sender) .setRemoteDescription(this.createSessionDescription(msg.answer)) .catch((reason) =&gt; { console.error('Setting answer error: ' + reason) }) } else if ('candidate' in msg) { connections.addIceCandidate(msg.sender, this.createIceCandidate(msg.candidate)) .catch((reason) =&gt; { console.error('Setting candidate error: ', reason) }) } } /** * Creates a peer connection and generates an SDP offer. * * @param {WebRTCService~onCandidate} onCandidate - Ice candidate event handler. * @param {WebRTCService~onSDP} sendOffer - Session description event handler. * @param {WebRTCService~onChannel} onChannel - Handler event when the data channel is ready. * @return {Promise} - Resolved when the offer has been succesfully created, * set as local description and sent to the peer. */ createPeerConnectionAndOffer (onCandidate, sendOffer, onChannel) { let pc = this.createPeerConnection(onCandidate) let dc = pc.createDataChannel(null) pc.oniceconnectionstatechange = () =&gt; { if (pc.iceConnectionState === 'disconnected') { dc.onclose() } } dc.onopen = (evt) =&gt; onChannel(dc) return pc.createOffer() .then((offer) =&gt; pc.setLocalDescription(offer)) .then(() =&gt; { sendOffer(pc.localDescription.toJSON()) return pc }) } /** * Creates a peer connection and generates an SDP answer. * * @param {WebRTCService~onCandidate} onCandidate - Ice candidate event handler. * @param {WebRTCService~onSDP} sendOffer - Session description event handler. * @param {WebRTCService~onChannel} onChannel - Handler event when the data channel is ready. * @param {Object} offer - Offer received from a peer. * @return {Promise} - Resolved when the offer has been succesfully created, * set as local description and sent to the peer. */ createPeerConnectionAndAnswer (onCandidate, sendAnswer, onChannel, offer) { let pc = this.createPeerConnection(onCandidate) pc.ondatachannel = (dcEvt) =&gt; { let dc = dcEvt.channel pc.oniceconnectionstatechange = () =&gt; { if (pc.iceConnectionState === 'disconnected') { dc.onclose() } } dc.onopen = (evt) =&gt; onChannel(dc) } return pc.setRemoteDescription(this.createSessionDescription(offer)) .then(() =&gt; pc.createAnswer()) .then((answer) =&gt; pc.setLocalDescription(answer)) .then(() =&gt; { sendAnswer(pc.localDescription.toJSON()) return pc }) } /** * Creates an instance of `RTCPeerConnection` and sets `onicecandidate` event handler. * * @private * @param {WebRTCService~onCandidate} onCandidate - Ice * candidate event handler. * @return {external:RTCPeerConnection} - Peer connection. */ createPeerConnection (onCandidate) { let pc = new RTCPeerConnection({iceServers: this.settings.iceServers}) pc.onicecandidate = (evt) =&gt; { if (evt.candidate !== null) { let candidate = { candidate: evt.candidate.candidate, sdpMLineIndex: evt.candidate.sdpMLineIndex } onCandidate(candidate) } } return pc } /** * Creates an instance of `RTCIceCandidate`. * * @private * @param {Object} candidate - Candidate object created in * {@link WebRTCService#createPeerConnection}. * @param {} candidate.candidate * @param {} candidate.sdpMLineIndex * @return {external:RTCIceCandidate} - Ice candidate. */ createIceCandidate (candidate) { return new RTCIceCandidate(candidate) } /** * Creates an instance of `RTCSessionDescription`. * * @private * @param {Object} sd - An offer or an answer created by WebRTC API. * @param {} sd.type * @param {} sd.sdp * @return {external:RTCSessionDescription} - Session description. */ createSessionDescription (sd) { return Object.assign(new RTCSessionDescription(), sd) } getPendingConnections (wc) { if (connectionsByWC.has(wc.id)) { return connectionsByWC.get(wc.id) } else { let connections = new RTCPendingConnections() connectionsByWC.set(wc.id, connections) return connections } } } export default WebRTCService × Search results Close "},"service_channelBuilder_channelBuilder.js.html":{"id":"service_channelBuilder_channelBuilder.js.html","title":"Source: service/channelBuilder/channelBuilder.js","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Source: service/channelBuilder/channelBuilder.js import {ServiceInterface} from '../service' /** * Channel Builder module is responsible to create a connection between two * peers. * @module channelBuilder * @see Channel */ /** * On channel callback for {@link module:channelBuilder~Interface#open} * function. * * @callback module:channelBuilder~onChannelCallback * @param {Channel} channel - A new channel. */ /** * Call back to initialize the channel. It should be executed on both peer * sides during connection establishment to assure that both channels would be * ready to be used in the web channel. * * @callback module:channelBuilder~initChannel * @param {Channel} ch - Channel. * @param {string} id - Unique channel identifier. */ /** * Interface to be implemented by each connection service. * * @interface * @extends module:service~Interface */ class ChannelBuilderInterface extends ServiceInterface { constructor () { super() } /** * Enables other clients to establish a connection with you. * * @abstract * @param {string} key - The unique identifier which has to be passed to the * peers who need to connect to you. * @param {module:channelBuilder~Interface~onChannelCallback} onChannel - Callback * function to execute once the connection has been established. * @param {Object} [options] - Any other options which depend on the service implementation. * @return {Promise} - Once resolved, provide an Object with `key` and `url` * attributes to be passed to {@link module:channelBuilder~Interface#join} function. * It is rejected if an error occured. */ open (key, onChannel, options) { throw new Error('Must be implemented by subclass!') } /** * Connects you with the peer who provided the `key`. * * @abstract * @param {string} key - A key obtained from the peer who executed * {@link module:channelBuilder~Interface#open} function. * @param {Object} [options] Any other options which depend on the implementation. * @return {Promise} It is resolved when the connection is established, otherwise it is rejected. */ join (key, options) { throw new Error('Must be implemented by subclass!') } /** * Establish a connection between you and another peer (including joining peer) via web channel. * * @abstract * @param {WebChannel} wc - Web Channel through which the connection will be established. * @param {string} id - Peer id with whom you will be connected. * @return {Promise} - Resolved once the connection has been established, rejected otherwise. */ connectMeTo (wc, id) { throw new Error('Must be implemented by subclass!') } } export { /** @see module:channelBuilder~Interface */ ChannelBuilderInterface } × Search results Close "},"service_service.js.html":{"id":"service_service.js.html","title":"Source: service/service.js","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Source: service/service.js /** * Service module includes {@link module:channelBuilder}, * {@link module:webChannelManager} and {@link module:channelProxy} modules. * Services are substitutable stateless objects. Each service is identified by * its class name and can receive messages via `WebChannel` sent by another * service. * * @module service * @see module:channelBuilder * @see module:webChannelManager * @see module:channelProxy */ /** * Each service must implement this interface. * * @interface */ class ServiceInterface { /** * Service name which corresponds to its class name. * * @return {string} - name */ get name () { return this.constructor.name } } export { /** @see module:service~Interface */ ServiceInterface } × Search results Close "},"service_webChannelManager_FullyConnectedService.js.html":{"id":"service_webChannelManager_FullyConnectedService.js.html","title":"Source: service/webChannelManager/FullyConnectedService.js","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Source: service/webChannelManager/FullyConnectedService.js import {WebChannelManagerInterface} from './webChannelManager' /** * Fully connected web channel manager. Implements fully connected topology * network, when each peer is connected to each other. * * @extends module:webChannelManager~Interface */ class FullyConnectedService extends WebChannelManagerInterface { constructor () { super() } add (channel) { let wc = channel.webChannel let peerIds = new Set([wc.myId]) let jpIds = new Set() wc.channels.forEach((c) =&gt; peerIds.add(c.peerId)) wc.getJoiningPeers().forEach((jp) =&gt; { if (channel.peerId !== jp.id &amp;&amp; !peerIds.has(jp.id)) { jpIds.add(jp.id) } }) return this.connectWith(wc, channel.peerId, channel.peerId, [...peerIds], [...jpIds]) } broadcast (webChannel, data) { for (let c of webChannel.channels) { c.send(data) } } sendTo (id, webChannel, data) { for (let c of webChannel.channels) { if (c.peerId === id) { c.send(data) return } } } leave (webChannel) {} } export default FullyConnectedService × Search results Close "},"service_webChannelManager_webChannelManager.js.html":{"id":"service_webChannelManager_webChannelManager.js.html","title":"Source: service/webChannelManager/webChannelManager.js","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Source: service/webChannelManager/webChannelManager.js import {ServiceInterface} from '../service' import {provide} from '../../serviceProvider' /** * Web Channel Manager module is a submodule of {@link module:service} and the * main component of any Web Channel. It is responsible to preserve Web Channel * structure intact (i.e. all peers have the same vision of the Web Channel). * Among its duties are: * * - Add a new peer into Web Channel. * - Remove a peer from Web Channel. * - Send a broadcast message. * - Send a message to a particular peer. * * @module webChannelManager * @see FullyConnectedService */ /** * Connection service of the peer who received a message of this type should * establish connection with one or several peers. */ const CONNECT_WITH = 1 const CONNECT_WITH_FEEDBACK = 2 const THIS_CHANNEL_TO_JOINING_PEER = 3 const CONNECT_WITH_TIMEOUT = 5000 /** * Each Web Channel Manager Service must implement this interface. * @interface * @extends module:service~Interface */ class WebChannelManagerInterface extends ServiceInterface { constructor () { super() } onMessage (wc, channel, msg) { let cBuilder = provide(wc.settings.connector, wc.settings) switch (msg.code) { case CONNECT_WITH: if (wc.isJoining()) { msg.joiningPeers.forEach((jp) =&gt; { wc.addJoiningPeer(jp.jpId, jp.intermediaryId) msg.peerIds.push(jp.jpId) }) } // console.log('Me ' + wc.myId + ' should connect to ----&gt; ', msg.peerIds) msg.peerIds = this.reUseIntermediaryChannelIfPossible(wc, msg.jpId, msg.peerIds) let failed = [] if (msg.peerIds.length === 0) { wc.sendSrvMsg(this.name, msg.sender, {code: CONNECT_WITH_FEEDBACK, id: wc.myId, failed} ) } else { // console.log('Me ' + wc.myId + ' should connect to ----&gt; ' + msg.peerIds + '--reUseIntermediaryChannelIfPossible') let counter = 0 msg.peerIds.forEach((id) =&gt; { cBuilder.connectMeTo(wc, id) .then((channel) =&gt; { return wc.initChannel(channel, true, id) }) .then((channel) =&gt; { // console.log('PEER ' + wc.myId + ' CONNECTED TO ' + channel.peerId) counter++ let jp = wc.getJoiningPeer(msg.jpId) jp.toAddList(channel) wc.sendSrvMsg(this.name, channel.peerId, {code: THIS_CHANNEL_TO_JOINING_PEER, jpId: msg.jpId, intermediaryId: jp.intermediaryId, toBeAdded: true}, channel ) if (counter === msg.peerIds.length) { wc.sendSrvMsg(this.name, msg.sender, {code: CONNECT_WITH_FEEDBACK, id: wc.myId, failed} ) } }) .catch((reason) =&gt; { counter++ failed.push({id, reason}) if (counter === msg.peerIds.length) { wc.sendSrvMsg(this.name, msg.sender, {code: CONNECT_WITH_FEEDBACK, id: wc.myId, failed} ) } }) }) } break case CONNECT_WITH_FEEDBACK: wc.connectWithRequests.get(msg.id)(true) break case THIS_CHANNEL_TO_JOINING_PEER: let jp if (wc.hasJoiningPeer(msg.jpId)) { jp = wc.getJoiningPeer(msg.jpId) } else { jp = wc.addJoiningPeer(msg.jpId, msg.intermediaryId) } if (msg.toBeAdded) { jp.toAddList(channel) } else { jp.toRemoveList(channel) } break } } /** * Send a request to a peer asking him to establish a connection with some * peers. This function is used when a new peer is joining Web Channel. * The request can be sent to the peer who is joining as well as other peers * who are already members of Web Channel. * * @param {WebChannel} wc - The Web Channel. * @param {string} id - Id of the peer who will receive this request. * @param {string} jpId - Joining peer id (it is possible that `id`=`jpId`). * @param {string[]} peerIds - Ids of peers with whom `id` peer must established * connections. * @return {Promise} - Is resolved once some of the connections could be established. It is rejected when an error occured. */ connectWith (wc, id, jpId, peerIds, jpIds) { let joiningPeers = [] jpIds.forEach((id) =&gt; { let jp = wc.getJoiningPeer(id) joiningPeers.push({ jpId: jp.id, intermediaryId: jp.intermediaryId }) }) wc.sendSrvMsg(this.name, id, {code: CONNECT_WITH, jpId: jpId, sender: wc.myId, peerIds, joiningPeers} ) return new Promise((resolve, reject) =&gt; { wc.connectWithRequests.set(id, (isDone) =&gt; { if (isDone) { resolve() } else { reject() } }) setTimeout(() =&gt; { reject('CONNECT_WITH_TIMEOUT') }, this.calculateConnectWithTimeout(peerIds.length)) }) } calculateConnectWithTimeout (nbPeers) { if (nbPeers &gt; 0) { return CONNECT_WITH_TIMEOUT + Math.log10(nbPeers) } else { return CONNECT_WITH_TIMEOUT } } reUseIntermediaryChannelIfPossible (wc, jpId, ids) { let intermidiaryChannel let peerIndex for (let jp of wc.getJoiningPeers()) { if (jp.intermediaryChannel !== null) { peerIndex = ids.indexOf(jp.intermediaryId) if (peerIndex === -1) { peerIndex = ids.indexOf(jp.id) } if (peerIndex !== -1) { intermidiaryChannel = jp.intermediaryChannel break } } } let jp = wc.getJoiningPeer(jpId) jp.toAddList(intermidiaryChannel) wc.sendSrvMsg(this.name, jp.intermediaryId, {code: THIS_CHANNEL_TO_JOINING_PEER, jpId, intermediaryId: jp.intermediaryId, toBeAdded: true}, intermidiaryChannel ) ids.splice(peerIndex, 1) return ids } /** * Adds a new peer into Web Channel. * * @abstract * @param {Channel} ch - Channel to be added (it should has * the `webChannel` property). * @return {Promise} - Resolved once the channel has been succesfully added, * rejected otherwise. */ add (ch) { throw new Error('Must be implemented by subclass!') } /** * Send a message to all peers in Web Channel. * * @abstract * @param {WebChannel} wc - Web Channel where the message will be propagated. * @param {string} data - Data in stringified JSON format to be send. */ broadcast (wc, data) { throw new Error('Must be implemented by subclass!') } /** * Send a message to a particular peer in Web Channel. * * @abstract * @param {string} id - Peer id. * @param {WebChannel} wc - Web Channel where the message will be propagated. * @param {string} data - Data in stringified JSON format to be send. */ sendTo (id, wc, data) { throw new Error('Must be implemented by subclass!') } /** * Leave Web Channel. * * @abstract * @param {WebChannel} wc - Web Channel to leave. */ leave (wc) { throw new Error('Must be implemented by subclass!') } } export { /** @see module:webChannelManager~Interface */ WebChannelManagerInterface } × Search results Close "},"serviceProvider.js.html":{"id":"serviceProvider.js.html","title":"Source: serviceProvider.js","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Source: serviceProvider.js import FullyConnectedService from './service/webChannelManager/FullyConnectedService' import WebRTCService from './service/channelBuilder/WebRTCService' import {MessageBuilderService} from './service/MessageBuilderService' /** * Service Provider module is a helper module for {@link module:service}. It is * responsible to instantiate all services. This module must be used to get * any service instance. * @module serviceProvider */ /** * Constant used to get an instance of {@link WebRTCService}. * @type {string} */ const WEBRTC = 'WebRTCService' /** * Constant used to get an instance of {@link FullyConnectedService}. * @type {string} */ const FULLY_CONNECTED = 'FullyConnectedService' const MESSAGE_BUILDER = 'MessageBuilderService' const services = new Map() /** * Provides the service instance specified by `name`. * * @param {(module:serviceProvider.CHANNEL_PROXY| * module:serviceProvider.WEBRTC| * module:serviceProvider.FULLY_CONNECTED)} name - The service name. * @param {Object} [options] - Any options that the service accepts. * @return {module:service~Interface} - Service instance. */ let provide = function (name, options = {}) { if (services.has(name)) { return services.get(name) } let service switch (name) { case WEBRTC: return new WebRTCService(options) case FULLY_CONNECTED: service = new FullyConnectedService() services.set(name, service) return service case MESSAGE_BUILDER: service = new MessageBuilderService() services.set(name, service) return service default: return null } } export {WEBRTC, FULLY_CONNECTED, MESSAGE_BUILDER, provide} × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Global Members &lt;constant&gt; USER_DATA :int One of the internal message type. It's a peer message. Type: int Source: WebChannel.js, line 15 &lt;constant&gt; SERVICE_DATA :int One of the internal message type. This message should be threated by a specific service class Type: int Source: WebChannel.js, line 22 &lt;constant&gt; LEAVE :int One of the internal message type. Means a peer has left the WebChannel. Type: int Source: WebChannel.js, line 28 &lt;constant&gt; JOIN_INIT :int One of the internal message type. Initialization message for the joining peer. Type: int Source: WebChannel.js, line 35 &lt;constant&gt; JOIN_NEW_MEMBER :int One of the internal message type. The message is intended for the WebChannel members to notify them about the joining peer. Type: int Source: WebChannel.js, line 41 &lt;constant&gt; REMOVE_NEW_MEMBER :int One of the internal message type. The message is intended for the WebChannel members to notify them that the joining peer has not succeed. Type: int Source: WebChannel.js, line 48 &lt;constant&gt; JOIN_FINILIZE :int Constant used to build a message to be sent to a newly joining peer that he has can now succesfully join Web Channel. Type: int Source: WebChannel.js, line 55 &lt;constant&gt; JOIN_SUCCESS :int Constant used to build a message to be sent by the newly joining peer to all peers in Web Channel to notify them that he has succesfully joined the Web Channel. Type: int Source: WebChannel.js, line 62 &lt;constant&gt; INIT_CHANNEL_PONG :int Type: int Source: WebChannel.js, line 66 &lt;constant&gt; PING :int Type: int Source: WebChannel.js, line 70 &lt;constant&gt; PONG :int Type: int Source: WebChannel.js, line 74 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Modules Classes JoiningPeer WebChannel RTCPendingConnections WebRTCService FullyConnectedService × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Classes Classes JoiningPeer WebChannel RTCPendingConnections WebRTCService FullyConnectedService × Search results Close "},"interfaces.list.html":{"id":"interfaces.list.html","title":"Interfaces","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Interfaces Classes JoiningPeer WebChannel RTCPendingConnections WebRTCService FullyConnectedService × Search results Close "},"externals.list.html":{"id":"externals.list.html","title":"Externals","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Externals Classes JoiningPeer WebChannel RTCPendingConnections WebRTCService FullyConnectedService × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Abstract peer to peer client transport API. Implementations based on WebRTC and WebSocket to be done. Documentation: https://coast-team.github.io/netflux RemarkWhen using API, it may not work from the first attempt. This is because WebRTC uses ws://sigver-coastteam.rhcloud.com:8000 signaling server by default. Due to the rhcloud application hosting specification, following a period of inactivity, the server will be available after a while. Try it again a few seconds later. Supported browsersChrome 49 and above Firefox 45 and above API specification (warning: alpha state)RemarksPerhaps WebChannel.openForJoining and WebChannel.closeForJoining could be used in case of WebRTC and WebSocket. Maybe leave the possibility to the API user to decide either is an invite-only WebChannel or not. Lets implement and see. WebChannel See http://coast-team.github.io/netflux/WebChannel.html UML The Green and green/red parts (Facade, WebChannel and Peer) is what we consider to expose to the API user). The Gray parts represent some of internal elements of the API. The White parts are not yet implemented. × Search results Close "},"Channel.html":{"id":"Channel.html","title":"Interface: Channel","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Interface: Channel Channel Channel interface. RTCDataChannel and WebSocket implement it implicitly. Any other channel must implement this interface. Source: Channel.js, line 10 Methods &lt;abstract&gt; send(msg) send - description. Parameters: Name Type Description msg string Message in stringified JSON format. Source: Channel.js, line 30 &lt;abstract&gt; close() Close channel. Source: Channel.js, line 41 × Search results Close "},"JoiningPeer.html":{"id":"JoiningPeer.html","title":"Class: JoiningPeer","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Class: JoiningPeer JoiningPeer This class represents a temporary state of a peer, while he is about to join the web channel. During the joining process every peer in the web channel and the joining peer have an instance of this class with the same id and intermediaryId attribute values. After the joining process has been finished regardless of success, these instances will be deleted. new JoiningPeer() Source: JoiningPeer.js, line 8 Members id :string The joining peer id. Type: string Source: JoiningPeer.js, line 15 intermediaryId :string The id of the peer who invited the joining peer to the web channel. It is a member of the web channel and called an intermediary peer between the joining peer and the web channel. The same value for all instances. Type: string Source: JoiningPeer.js, line 24 intermediaryChannel :Channel The channel between the joining peer and intermediary peer. It is null for every peer, but the joining and intermediary peers. Type: Channel Source: JoiningPeer.js, line 32 channelsToAdd :Array.&lt;Channel&gt; This attribute is proper to each peer. Array of channels which will be added to the current peer once the joining peer become the member of the web channel. Type: Array.&lt;Channel&gt; Source: JoiningPeer.js, line 41 channelsToRemove :Array.&lt;Channel&gt; This attribute is proper to each peer. Array of channels which will be closed with the current peer once the joining peer become the member of the web channel. Type: Array.&lt;Channel&gt; Source: JoiningPeer.js, line 50 Methods toAddList(channel) Add channel to channelsToAdd array. Parameters: Name Type Description channel Channel Channel to add. Source: JoiningPeer.js, line 58 toRemoveList(channel) Add channel to channelsToRemove array Parameters: Name Type Description channel Channel Channel to add. Source: JoiningPeer.js, line 67 × Search results Close "},"WebChannel.html":{"id":"WebChannel.html","title":"Class: WebChannel","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Class: WebChannel WebChannel This class is an API starting point. It represents a group of collaborators also called peers. Each peer can send/receive broadcast as well as personal messages. Every peer in the WebChannel can invite another person to join the WebChannel and he also possess enough information to be able to add it preserving the current WebChannel structure (network topology). new WebChannel( [options]) WebChannel constructor. WebChannel can be parameterized in terms of network topology and connector technology (WebRTC or WebSocket. Currently WebRTC is only available). Parameters: Name Type Argument Description options Object &lt;optional&gt; WebChannel configuration. Properties Name Type Argument Default Description topology string &lt;optional&gt; FULLY_CONNECTED Defines the network topology. connector string &lt;optional&gt; WEBRTC Determines the connection technology to use for build WebChannel. Source: WebChannel.js, line 112 Members &lt;private&gt; channels Channels through which this peer is connected with other peers. This attribute depends on the WebChannel topology. E. g. in fully connected WebChannel you are connected to each other peer in the group, however in the star structure this attribute contains only the connection to the central peer. Source: WebChannel.js, line 151 &lt;private&gt; onJoin This event handler is used to resolve Promise in WebChannel.join. Source: WebChannel.js, line 158 &lt;private&gt; joiningPeers Source: WebChannel.js, line 161 &lt;private&gt; connectWithRequests Source: WebChannel.js, line 163 &lt;private&gt; peerNb Source: WebChannel.js, line 168 &lt;private&gt; pingTime Source: WebChannel.js, line 170 &lt;private&gt; gate Source: WebChannel.js, line 173 &lt;readonly&gt; id Unique identifier of this WebChannel. The same for all peers. Source: WebChannel.js, line 179 &lt;readonly&gt; myId Unique peer identifier of you in this WebChannel. After each join function call this id will change, because it is up to the WebChannel to assign it when you join. Source: WebChannel.js, line 188 topology // TODO: add doc Source: WebChannel.js, line 377 &lt;private&gt; topology // TODO: add doc Source: WebChannel.js, line 523 Methods onJoining(id) Is the event handler called when a new peer has joined the WebChannel. Parameters: Name Type Description id number Id of the joined peer Source: WebChannel.js, line 195 onMessage(id, data, isBroadcast) Is the event handler called when a message is available on the WebChannel. Parameters: Name Type Description id number Id of the peer who sent this message data string | external:ArrayBufferView Message isBroadcast boolean It is true if the message is sent via send method and false if it is sent via sendTo method Source: WebChannel.js, line 206 onLeaving(id) Is the event handler called when a peer hes left the WebChannel. Parameters: Name Type Description id number Id of the peer who has left Source: WebChannel.js, line 213 onClose(id) Is the event handler called when the WebChannel has been closed. Parameters: Name Type Description id external:CloseEvent Close event object Source: WebChannel.js, line 220 openForJoining( [options]) Enable other peers to join the WebChannel with your help as an intermediary peer. Parameters: Name Type Argument Description options Object &lt;optional&gt; Any available connection service options Source: WebChannel.js, line 231 Returns: It is resolved once the WebChannel is open. The callback function take a parameter of type WebChannel~AccessData. Type PromiseWebChannel~AccessData closeForJoining() Prevent clients to join the WebChannel even if they possesses a key. Source: WebChannel.js, line 267 isOpen() If the WebChannel is open, the clients can join it through you, otherwise it is not possible. Source: WebChannel.js, line 277 Returns: True if the WebChannel is open, false otherwise Type boolean join(key [, options]) Join the WebChannel. Parameters: Name Type Argument Description key string The key provided by one of the WebChannel members. options type &lt;optional&gt; Any available connection service options. Source: WebChannel.js, line 288 Returns: It resolves once you became a WebChannel member. Type Promise leave() Leave the WebChannel. No longer can receive and send messages to the group. Source: WebChannel.js, line 303 send(data) Send the message to all WebChannel members. Parameters: Name Type Description data string | external:ArrayBufferView Message Source: WebChannel.js, line 320 sendTo(id, data) Send the message to a particular peer in the WebChannel. Parameters: Name Type Description id number Id of the recipient peer data string | external:ArrayBufferView Message Source: WebChannel.js, line 334 getAccess() Get the data which should be provided to all clients who must join the WebChannel. It is the same data which WebChannel#openForJoining callback function provides. Source: WebChannel.js, line 350 Returns: Data to join the WebChannel or null is the WebChannel is closed Type WebChannel~AccessData | null ping() Get the ping of the WebChannel. It is an amount in milliseconds which corresponds to the longest ping to each WebChannel member. Source: WebChannel.js, line 360 Returns: Type Promise &lt;private&gt; sendSrvMsg(serviceName, recepient [, msg]) Send a message to a service of the same peer, joining peer or any peer in the Web Channel). Parameters: Name Type Argument Default Description serviceName string Service name. recepient string Identifier of recepient peer id. msg Object &lt;optional&gt; {} Message to send. Source: WebChannel.js, line 390 &lt;private&gt; onChannelMessage() // TODO: add doc Source: WebChannel.js, line 430 &lt;private&gt; onChannelError() // TODO: add doc Source: WebChannel.js, line 505 &lt;private&gt; onChannelClose() // TODO: add doc Source: WebChannel.js, line 514 &lt;private&gt; initChannel() // TODO: add doc Source: WebChannel.js, line 533 &lt;private&gt; joinSuccess(id) joinSuccess - description Parameters: Name Type Description id type description Source: WebChannel.js, line 561 Returns: description Type type &lt;private&gt; getJoiningPeer(id) TODO: add doc Parameters: Name Type Description id type description Source: WebChannel.js, line 576 &lt;private&gt; getJoiningPeers() TODO: add doc Source: WebChannel.js, line 593 &lt;private&gt; addJoiningPeer(jp) TODO: add doc Parameters: Name Type Description jp type description Source: WebChannel.js, line 604 Returns: description Type type &lt;private&gt; removeJoiningPeer(id) TODO: add doc Parameters: Name Type Description id type description Source: WebChannel.js, line 623 Returns: description Type type &lt;private&gt; isJoining() TODO: add doc Source: WebChannel.js, line 635 Returns: description Type type &lt;private&gt; hasJoiningPeer(id) TODO: add doc Parameters: Name Type Description id type description Source: WebChannel.js, line 651 Returns: description Type type &lt;private&gt; generateKey() TODO: add doc Source: WebChannel.js, line 666 Returns: description Type type &lt;private&gt; generateId() TODO: add doc Source: WebChannel.js, line 685 Returns: description Type type Type Definitions AccessData When the WebChannel is open, any clients should you this data to join the WebChannel. Type: Object Properties: Name Type Description key string The key to join the WebChannel url string Signaling server URL to use to join the WebChannel Source: WebChannel.js, line 114 × Search results Close "},"external-JSON.html":{"id":"external-JSON.html","title":"External: JSON","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView External: JSON JSON Source: index.js, line 5 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON × Search results Close "},"external-Error.html":{"id":"external-Error.html","title":"External: Error","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView External: Error Error Source: index.js, line 9 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Error × Search results Close "},"external-RTCPeerConnection.html":{"id":"external-RTCPeerConnection.html","title":"External: RTCPeerConnection","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView External: RTCPeerConnection RTCPeerConnection Source: index.js, line 13 See: https://developer.mozilla.org/en/docs/Web/API/RTCPeerConnection × Search results Close "},"external-RTCSessionDescription.html":{"id":"external-RTCSessionDescription.html","title":"External: RTCSessionDescription","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView External: RTCSessionDescription RTCSessionDescription Source: index.js, line 17 See: https://developer.mozilla.org/en/docs/Web/API/RTCSessionDescription × Search results Close "},"external-RTCDataChannel.html":{"id":"external-RTCDataChannel.html","title":"External: RTCDataChannel","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView External: RTCDataChannel RTCDataChannel Source: index.js, line 21 See: https://developer.mozilla.org/en/docs/Web/API/RTCDataChannel × Search results Close "},"external-RTCIceCandidate.html":{"id":"external-RTCIceCandidate.html","title":"External: RTCIceCandidate","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView External: RTCIceCandidate RTCIceCandidate Source: index.js, line 25 See: https://developer.mozilla.org/en/docs/Web/API/RTCIceCandidate × Search results Close "},"external-RTCPeerConnectionIceEvent.html":{"id":"external-RTCPeerConnectionIceEvent.html","title":"External: RTCPeerConnectionIceEvent","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView External: RTCPeerConnectionIceEvent RTCPeerConnectionIceEvent Source: index.js, line 29 See: https://developer.mozilla.org/en/docs/Web/API/RTCPeerConnectionIceEvent × Search results Close "},"external-CloseEvent.html":{"id":"external-CloseEvent.html","title":"External: CloseEvent","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView External: CloseEvent CloseEvent Source: index.js, line 33 See: https://developer.mozilla.org/en/docs/Web/API/CloseEvent/CloseEvent × Search results Close "},"external-ArrayBufferView.html":{"id":"external-ArrayBufferView.html","title":"External: ArrayBufferView","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView External: ArrayBufferView ArrayBufferView Source: index.js, line 37 See: https://developer.mozilla.org/en/docs/Web/API/ArrayBufferView × Search results Close "},"WebRTCService.html":{"id":"WebRTCService.html","title":"Class: WebRTCService","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Class: WebRTCService WebRTCService Service class responsible to establish connections between peers via RTCDataChannel. new WebRTCService( [options]) WebRTCService constructor. Parameters: Name Type Argument Description options Object &lt;optional&gt; This service options. Properties Name Type Argument Default Description signaling Object &lt;optional&gt; 'wws://sigver-coastteam.rhcloud.com:8000' Signaling server URL. iceServers Array.&lt;Object&gt; &lt;optional&gt; [{urls: 'stun:23.21.150.121'},{urls: 'stun:stun.l.google.com:19302'},{urls: 'turn:numb.viagenie.ca', credential: 'webrtcdemo', username: 'louis%40mozilla.com'}] WebRTC options to setup which STUN and TURN servers to be used. Source: service/channelBuilder/WebRTCService.js, line 112 See: external:RTCPeerConnection Extends module:channelBuilder~Interface Methods createPeerConnectionAndOffer(onCandidate, sendOffer, onChannel) Creates a peer connection and generates an SDP offer. Parameters: Name Type Description onCandidate WebRTCService~onCandidate Ice candidate event handler. sendOffer WebRTCService~onSDP Session description event handler. onChannel WebRTCService~onChannel Handler event when the data channel is ready. Source: service/channelBuilder/WebRTCService.js, line 298 Returns: Resolved when the offer has been succesfully created, set as local description and sent to the peer. Type Promise createPeerConnectionAndAnswer(onCandidate, sendOffer, onChannel, offer) Creates a peer connection and generates an SDP answer. Parameters: Name Type Description onCandidate WebRTCService~onCandidate Ice candidate event handler. sendOffer WebRTCService~onSDP Session description event handler. onChannel WebRTCService~onChannel Handler event when the data channel is ready. offer Object Offer received from a peer. Source: service/channelBuilder/WebRTCService.js, line 325 Returns: Resolved when the offer has been succesfully created, set as local description and sent to the peer. Type Promise &lt;private&gt; createPeerConnection(onCandidate) Creates an instance of RTCPeerConnection and sets onicecandidate event handler. Parameters: Name Type Description onCandidate WebRTCService~onCandidate Ice candidate event handler. Source: service/channelBuilder/WebRTCService.js, line 353 Returns: Peer connection. Type external:RTCPeerConnection &lt;private&gt; createIceCandidate(candidate) Creates an instance of RTCIceCandidate. Parameters: Name Type Description candidate Object Candidate object created in WebRTCService#createPeerConnection. Properties Name Type Description candidate sdpMLineIndex Source: service/channelBuilder/WebRTCService.js, line 377 Returns: Ice candidate. Type external:RTCIceCandidate &lt;private&gt; createSessionDescription(sd) Creates an instance of RTCSessionDescription. Parameters: Name Type Description sd Object An offer or an answer created by WebRTC API. Properties Name Type Description type sdp Source: service/channelBuilder/WebRTCService.js, line 390 Returns: Session description. Type external:RTCSessionDescription Type Definitions onCandidate(evt) Ice candidate event handler. Parameters: Name Type Description evt external:RTCPeerConnectionIceEvent Event. Source: service/channelBuilder/WebRTCService.js, line 3 onSDP(evt) Session description event handler. Parameters: Name Type Description evt external:RTCPeerConnectionIceEvent Event. Source: service/channelBuilder/WebRTCService.js, line 10 onChannel(evt) Data channel event handler. Parameters: Name Type Description evt external:RTCPeerConnectionIceEvent Event. Source: service/channelBuilder/WebRTCService.js, line 17 × Search results Close "},"RTCPendingConnections.html":{"id":"RTCPendingConnections.html","title":"Class: RTCPendingConnections","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Class: RTCPendingConnections RTCPendingConnections The goal of this class is to prevent the error when adding an ice candidate before the remote description has been set. new RTCPendingConnections() Source: service/channelBuilder/WebRTCService.js, line 28 Methods add(id) Prepares pending connection for the specified peer only if it has not been added already. Parameters: Name Type Description id string Peer id Source: service/channelBuilder/WebRTCService.js, line 38 remove(id) Remove a pending connection from the Map. Usually when the connection has already been established and there is now interest to hold this reference. Parameters: Name Type Description id string Peer id. Source: service/channelBuilder/WebRTCService.js, line 62 getPC(id) Returns RTCPeerConnection object for the provided peer id. Parameters: Name Type Description id string Peer id. Source: service/channelBuilder/WebRTCService.js, line 72 Returns: Peer connection. Type external:RTCPeerConnection setPC(id, pc) Updates RTCPeerConnection reference for the provided peer id. Parameters: Name Type Description id string Peer id. pc external:RTCPeerConnection Peer connection. Source: service/channelBuilder/WebRTCService.js, line 82 addIceCandidate(id, candidate) When the remote description is set, it will add the ice candidate to the peer connection of specified peer. Parameters: Name Type Description id string Peer id. candidate external:RTCIceCandidate Ice candidate. Source: service/channelBuilder/WebRTCService.js, line 94 Returns: Resolved once the ice candidate has been succesfully added. Type Promise × Search results Close "},"module-channelBuilder.html":{"id":"module-channelBuilder.html","title":"Module: channelBuilder","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Module: channelBuilder Channel Builder module is responsible to create a connection between two peers. Source: service/channelBuilder/channelBuilder.js, line 2 See: Channel Members &lt;static&gt; ChannelBuilderInterface Source: service/channelBuilder/channelBuilder.js, line 84 See: module:channelBuilder~Interface Type Definitions onChannelCallback(channel) On channel callback for module:channelBuilder~Interface#open function. Parameters: Name Type Description channel Channel A new channel. Source: service/channelBuilder/channelBuilder.js, line 9 initChannel(ch, id) Call back to initialize the channel. It should be executed on both peer sides during connection establishment to assure that both channels would be ready to be used in the web channel. Parameters: Name Type Description ch Channel Channel. id string Unique channel identifier. Source: service/channelBuilder/channelBuilder.js, line 17 × Search results Close "},"module-channelBuilder-ChannelBuilderInterface.html":{"id":"module-channelBuilder-ChannelBuilderInterface.html","title":"Interface: ChannelBuilderInterface","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Interface: ChannelBuilderInterface channelBuilder~ ChannelBuilderInterface Interface to be implemented by each connection service. Source: service/channelBuilder/channelBuilder.js, line 33 Extends module:service~Interface Methods &lt;abstract&gt; open(key, onChannel [, options]) Enables other clients to establish a connection with you. Parameters: Name Type Argument Description key string The unique identifier which has to be passed to the peers who need to connect to you. onChannel module:channelBuilder~Interface~onChannelCallback Callback function to execute once the connection has been established. options Object &lt;optional&gt; Any other options which depend on the service implementation. Source: service/channelBuilder/channelBuilder.js, line 52 Returns: Once resolved, provide an Object with key and url attributes to be passed to module:channelBuilder~Interface#join function. It is rejected if an error occured. Type Promise &lt;abstract&gt; join(key [, options]) Connects you with the peer who provided the key. Parameters: Name Type Argument Description key string A key obtained from the peer who executed module:channelBuilder~Interface#open function. options Object &lt;optional&gt; Any other options which depend on the implementation. Source: service/channelBuilder/channelBuilder.js, line 65 Returns: It is resolved when the connection is established, otherwise it is rejected. Type Promise &lt;abstract&gt; connectMeTo(wc, id) Establish a connection between you and another peer (including joining peer) via web channel. Parameters: Name Type Description wc WebChannel Web Channel through which the connection will be established. id string Peer id with whom you will be connected. Source: service/channelBuilder/channelBuilder.js, line 77 Returns: Resolved once the connection has been established, rejected otherwise. Type Promise × Search results Close "},"module-service.html":{"id":"module-service.html","title":"Module: service","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Module: service Service module includes module:channelBuilder, module:webChannelManager and module:channelProxy modules. Services are substitutable stateless objects. Each service is identified by its class name and can receive messages via WebChannel sent by another service. Source: service/service.js, line 1 See: module:channelBuilder module:webChannelManager module:channelProxy Members &lt;static&gt; ServiceInterface Source: service/service.js, line 33 See: module:service~Interface × Search results Close "},"module-service-ServiceInterface.html":{"id":"module-service-ServiceInterface.html","title":"Interface: ServiceInterface","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Interface: ServiceInterface service~ ServiceInterface Each service must implement this interface. Source: service/service.js, line 19 Members name Service name which corresponds to its class name. Source: service/service.js, line 26 × Search results Close "},"FullyConnectedService.html":{"id":"FullyConnectedService.html","title":"Class: FullyConnectedService","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Class: FullyConnectedService FullyConnectedService Fully connected web channel manager. Implements fully connected topology network, when each peer is connected to each other. new FullyConnectedService() Source: service/webChannelManager/FullyConnectedService.js, line 9 Extends module:webChannelManager~Interface × Search results Close "},"module-webChannelManager.html":{"id":"module-webChannelManager.html","title":"Module: webChannelManager","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Module: webChannelManager Web Channel Manager module is a submodule of module:service and the main component of any Web Channel. It is responsible to preserve Web Channel structure intact (i.e. all peers have the same vision of the Web Channel). Among its duties are: Add a new peer into Web Channel. Remove a peer from Web Channel. Send a broadcast message. Send a message to a particular peer. Source: service/webChannelManager/webChannelManager.js, line 4 See: FullyConnectedService Members &lt;inner, constant&gt; CONNECT_WITH Connection service of the peer who received a message of this type should establish connection with one or several peers. Source: service/webChannelManager/webChannelManager.js, line 23 &lt;static&gt; WebChannelManagerInterface Source: service/webChannelManager/webChannelManager.js, line 238 See: module:webChannelManager~Interface × Search results Close "},"module-webChannelManager-WebChannelManagerInterface.html":{"id":"module-webChannelManager-WebChannelManagerInterface.html","title":"Interface: WebChannelManagerInterface","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Interface: WebChannelManagerInterface webChannelManager~ WebChannelManagerInterface Each Web Channel Manager Service must implement this interface. Source: service/webChannelManager/webChannelManager.js, line 34 Extends module:service~Interface Methods connectWith(wc, id, jpId, peerIds) Send a request to a peer asking him to establish a connection with some peers. This function is used when a new peer is joining Web Channel. The request can be sent to the peer who is joining as well as other peers who are already members of Web Channel. Parameters: Name Type Description wc WebChannel The Web Channel. id string Id of the peer who will receive this request. jpId string Joining peer id (it is possible that id=jpId). peerIds Array.&lt;string&gt; Ids of peers with whom id peer must established connections. Source: service/webChannelManager/webChannelManager.js, line 127 Returns: Is resolved once some of the connections could be established. It is rejected when an error occured. Type Promise &lt;abstract&gt; add(ch) Adds a new peer into Web Channel. Parameters: Name Type Description ch Channel Channel to be added (it should has the webChannel property). Source: service/webChannelManager/webChannelManager.js, line 198 Returns: Resolved once the channel has been succesfully added, rejected otherwise. Type Promise &lt;abstract&gt; broadcast(wc, data) Send a message to all peers in Web Channel. Parameters: Name Type Description wc WebChannel Web Channel where the message will be propagated. data string Data in stringified JSON format to be send. Source: service/webChannelManager/webChannelManager.js, line 209 &lt;abstract&gt; sendTo(id, wc, data) Send a message to a particular peer in Web Channel. Parameters: Name Type Description id string Peer id. wc WebChannel Web Channel where the message will be propagated. data string Data in stringified JSON format to be send. Source: service/webChannelManager/webChannelManager.js, line 221 &lt;abstract&gt; leave(wc) Leave Web Channel. Parameters: Name Type Description wc WebChannel Web Channel to leave. Source: service/webChannelManager/webChannelManager.js, line 231 × Search results Close "},"module-serviceProvider.html":{"id":"module-serviceProvider.html","title":"Module: serviceProvider","body":" Netflux v0.8.0 Modules channelBuilderservicewebChannelManagerserviceProvider Classes JoiningPeerWebChannelRTCPendingConnectionsWebRTCServiceFullyConnectedService Interfaces ChannelchannelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global USER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventArrayBufferView Module: serviceProvider Service Provider module is a helper module for module:service. It is responsible to instantiate all services. This module must be used to get any service instance. Source: serviceProvider.js, line 4 Members &lt;inner, constant&gt; WEBRTC :string Constant used to get an instance of WebRTCService. Type: string Source: serviceProvider.js, line 15 &lt;inner, constant&gt; FULLY_CONNECTED :string Constant used to get an instance of FullyConnectedService. Type: string Source: serviceProvider.js, line 21 Methods &lt;inner&gt; provide(name [, options]) Provides the service instance specified by name. Parameters: Name Type Argument Description name module:serviceProvider.CHANNEL_PROXY | module:serviceProvider.WEBRTC | module:serviceProvider.FULLY_CONNECTED The service name. options Object &lt;optional&gt; Any options that the service accepts. Source: serviceProvider.js, line 36 Returns: Service instance. Type module:service~Interface × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
