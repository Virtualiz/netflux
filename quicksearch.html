<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Channel.js.html":{"id":"Channel.js.html","title":"Source: Channel.js","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Source: Channel.js /** * Wrapper class for {@link external:RTCDataChannel} and * {@link external:WebSocket}. */ class Channel { /** * Creates *Channel* instance from existing data channel or web socket, assigns * it to the specified *WebChannel* and gives him an identifier. * @param {external:WebSocket|external:RTCDataChannel} - Data channel or web * socket * @param {WebChannel} - The *WebChannel* this channel will be part of * @param {number} peerId - Identifier of the peer who is at the other end of * this channel */ constructor (channel, webChannel, peerId) { // FIXME:this does not work for WebSocket channel.binaryType = 'arraybuffer' /** * Data channel or web socket. * @private * @type {external:WebSocket|external:RTCDataChannel} */ this.channel = channel /** * The *WebChannel* which this channel belongs to. * @type {WebChannel} */ this.webChannel = webChannel /** * Identifier of the peer who is at the other end of this channel * @type {WebChannel} */ this.peerId = peerId } /** * Configure this channel. Set up message, error and close event handlers. */ config () { this.channel.onmessage = (msgEvt) =&gt; { this.webChannel.onChannelMessage(this, msgEvt.data) } this.channel.onerror = (evt) =&gt; { this.webChannel.onChannelError(evt) } this.channel.onclose = (evt) =&gt; { this.webChannel.onChannelClose(evt) } } /** * Send message over this channel. The message should be prepared beforhand by * the {@link MessageBuilderService} * @see {@link MessageBuilderService#msg}, {@link MessageBuilderService#handleUserMessage} * @param {extternal:ArrayBuffer} data - Message */ send (data) { if (this.channel.readyState !== 'closed') { this.channel.send(data) } } /** * Close the channel. */ close () { this.channel.close() } } export default Channel × Search results Close "},"JoiningPeer.js.html":{"id":"JoiningPeer.js.html","title":"Source: JoiningPeer.js","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Source: JoiningPeer.js /** * This class represents a temporary state of a peer, while he is about to join * the web channel. During the joining process every peer in the web channel * and the joining peer have an instance of this class with the same `id` and * `intermediaryId` attribute values. After the joining process has been finished * regardless of success, these instances will be deleted. */ class JoiningPeer { constructor (id, intermediaryId, intermediaryChannel) { /** * The joining peer id. * * @type {string} */ this.id = id /** * The id of the peer who invited the joining peer to the web channel. It is * a member of the web channel and called an intermediary peer between the * joining peer and the web channel. The same value for all instances. * * @type {string} */ this.intermediaryId = intermediaryId /** * The channel between the joining peer and intermediary peer. It is null * for every peer, but the joining and intermediary peers. * * @type {Channel} */ this.intermediaryChannel = intermediaryChannel /** * This attribute is proper to each peer. Array of channels which will be * added to the current peer once the joining peer become the member of the * web channel. * * @type {Channel[]} */ this.channelsToAdd = [] /** * This attribute is proper to each peer. Array of channels which will be * closed with the current peer once the joining peer become the member of the * web channel. * * @type {Channel[]} */ this.channelsToRemove = [] } /** * Add channel to `channelsToAdd` array. * * @param {Channel} channel - Channel to add. */ toAddList (channel) { this.channelsToAdd[this.channelsToAdd.length] = channel } /** * Add channel to `channelsToRemove` array * * @param {Channel} channel - Channel to add. */ toRemoveList (channel) { this.channelsToAdd[this.channelsToAdd.length] = channel } } export default JoiningPeer × Search results Close "},"WebChannel.js.html":{"id":"WebChannel.js.html","title":"Source: WebChannel.js","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Source: WebChannel.js import {provide, FULLY_CONNECTED, WEBRTC, MESSAGE_BUILDER} from './serviceProvider' import Channel from './Channel' import JoiningPeer from './JoiningPeer' const msgBuilder = provide(MESSAGE_BUILDER) /** * Maximum identifier number for {@link WebChannel#generateId} function. * @type {number} */ const MAX_ID = 4294967295 /** * Timout for ping *WebChannel* in milliseconds. * @type {number} */ const PING_TIMEOUT = 5000 /** * One of the internal message type. It's a peer message. * @type {number} */ const USER_DATA = 1 /** * One of the internal message type. This message should be threated by a * specific service class. * @type {number} */ const SERVICE_DATA = 2 /** * One of the internal message type. Means a peer has left the *WebChannel*. * @type {number} */ const LEAVE = 3 /** * One of the internal message type. Initialization message for the joining peer. * @type {number} */ const JOIN_INIT = 4 /** * One of the internal message type. The message is intended for the *WebChannel* * members to notify them about the joining peer. * @type {number} */ const JOIN_NEW_MEMBER = 5 /** * One of the internal message type. The message is intended for the *WebChannel* * members to notify them that the joining peer has not succeed. * @type {number} */ const REMOVE_NEW_MEMBER = 6 /** * One of the internal message type. The message is intended for the joining peer * to notify him that everything is ready and he may join the *WebChannel*. * @type {number} */ const JOIN_FINILIZE = 7 /** * One of the internal message type. The message sent by the joining peer to * notify all *WebChannel* members about his arrivel. * @type {number} */ const JOIN_SUCCESS = 8 /** * One of the internal message type. This message is sent during Initialization * of a channel. * @see {@link WebChannel#initChannel} * @type {number} */ const INIT_CHANNEL_PONG = 10 /** * One of the internal message type. Ping message. * @type {number} */ const PING = 11 /** * One of the internal message type. Pong message, response to the ping message. * @type {number} */ const PONG = 12 /** * This class represents a door of the *WebChannel* for this peer. If the door * is open, then clients can join the *WebChannel* through this peer, otherwise * they cannot. */ class WebChannelGate { /** * @typedef {Object} WebChannelGate~AccessData * @property {string} key - The unique key to join the *WebChannel* * @property {string} url - Signaling server url */ /** * @param {WebChannelGate~onClose} onClose - close event handler */ constructor (onCloseHandler) { /** * Web socket which holds the connection with the signaling server. * @private * @type {external:WebSocket} */ this.door = null /** * Web socket which holds the connection with the signaling server. * @private * @type {WebChannel~AccessData} */ this.accessData = null /** * Close event handler. * @private * @type {WebChannelGate~onClose} */ this.onCloseHandler = onCloseHandler } /** * Get access data. * @returns {WebChannel~AccessData|null} - Returns access data if the door * is opened and *null* if it closed */ getAccessData () { return this.accessData } /** * Check if the door is opened or closed. * @returns {boolean} - Returns true if the door is opened and false if it is * closed */ isOpen () { return this.door !== null } /** * Open the door. * @param {external:WebSocket} door - Web socket to signalign server * @param {WebChannel~AccessData} accessData - Access data to join the * *WebChannel */ setOpen (door, accessData) { this.door = door this.door.onclose = this.onCloseHandler this.accessData = accessData } /** * Close the door if it is open and do nothing if it is closed already. */ close () { if (this.isOpen()) { this.door.close() this.door = null } } } /** * This class is an API starting point. It represents a group of collaborators * also called peers. Each peer can send/receive broadcast as well as personal * messages. Every peer in the *WebChannel* can invite another person to join * the *WebChannel* and he also possess enough information to be able to add it * preserving the current *WebChannel* structure (network topology). */ class WebChannel { /** * When the *WebChannel* is open, any clients should you this data to join * the *WebChannel*. * @typedef {Object} WebChannel~AccessData * @property {string} key - The unique key to join the *WebChannel* * @property {string} url - Signaling server url */ /** * *WebChannel* constructor. *WebChannel* can be parameterized in terms of * network topology and connector technology (WebRTC or WebSocket. Currently * WebRTC is only available). * @param {Object} [options] *WebChannel* configuration. * @param {string} [options.topology=FULLY_CONNECTED] Defines the network * topology. * @param {string} [options.connector=WEBRTC] Determines the connection * technology to use for build *WebChannel*. * @returns {WebChannel} Empty *WebChannel* without any connection. */ constructor (options = {}) { this.defaults = { connector: WEBRTC, topology: FULLY_CONNECTED } this.settings = Object.assign({}, this.defaults, options) /** * Channels through which this peer is connected with other peers. This * attribute depends on the *WebChannel* topology. E. g. in fully connected * *WebChannel* you are connected to each other peer in the group, however * in the star structure this attribute contains only the connection to * the central peer. * @private * @type {external:Set} */ this.channels = new Set() /** * This event handler is used to resolve *Promise* in {@link WebChannel#join}. * @private */ // TODO: add type to doc this.onJoin /** * Set of joining peers. * @private * @type {external:Set} */ this.joiningPeers = new Set() /** * Map of requests which is used to resolve *Promise* during joining peer * process. * @private * @type {external:Map} */ this.connectWithRequests = new Map() /** * *WebChannel* topology. * @private * @type {string} */ this.topology = this.settings.topology /** * Total peer number in the *WebChannel*. * @private * @type {number} */ this.peerNb = 0 /** * @private * @type {number} */ this.pingTime = 0 /** * The *WebChannel* gate. * @private * @type {WebChannelGate} */ this.gate = new WebChannelGate((closeEvt) =&gt; this.onClose(closeEvt)) /** * Unique identifier of this *WebChannel*. The same for all peers. * @readonly */ this.id = this.generateId() /** * Unique peer identifier of you in this *WebChannel*. After each `join` function call * this id will change, because it is up to the *WebChannel* to assign it when * you join. * @readonly */ this.myId = this.generateId() /** * Is the event handler called when a new peer has joined the *WebChannel*. * @param {number} id - Id of the joined peer */ this.onJoining = (id) =&gt; {} /** * Is the event handler called when a message is available on the *WebChannel*. * @param {number} id - Id of the peer who sent this message * @param {string|external:ArrayBufferView} data - Message * @param {boolean} isBroadcast - It is true if the message is sent via * [send]{@link WebChannel#send} method and false if it is sent via * [sendTo]{@link WebChannel#sendTo} method */ this.onMessage = (id, msg, isBroadcast) =&gt; {} /** * Is the event handler called when a peer hes left the *WebChannel*. * @param {number} id - Id of the peer who has left */ this.onLeaving = (id) =&gt; {} /** * Is the event handler called when the *WebChannel* has been closed. * @param {external:CloseEvent} id - Close event object */ this.onClose = (closeEvt) =&gt; {} } /** * Enable other peers to join the *WebChannel* with your help as an * intermediary peer. * @param {Object} [options] Any available connection service options * @returns {Promise} It is resolved once the *WebChannel* is open. The * callback function take a parameter of type {@link WebChannel~AccessData}. */ openForJoining (options = {}) { let settings = Object.assign({}, this.settings, options) let cBuilder = provide(settings.connector, settings) return cBuilder.open(this.generateKey(), (channel) =&gt; { this.initChannel(channel, false) .then((channel) =&gt; { // console.log('INITIATOR is adding: ' + channel.peerId) let jp = this.addJoiningPeer(channel.peerId, this.myId, channel) this.manager.broadcast(this, msgBuilder.msg( JOIN_NEW_MEMBER, {id: channel.peerId, intermediaryId: this.myId}) ) channel.send(msgBuilder.msg(JOIN_INIT, { manager: this.settings.topology, id: channel.peerId, intermediaryId: this.myId}) ) this.manager.add(channel) .then(() =&gt; channel.send(msgBuilder.msg(JOIN_FINILIZE))) .catch((msg) =&gt; { this.manager.broadcast(this, msgBuilder.msg( REMOVE_NEW_MEMBER, {id: channel.peerId}) ) this.removeJoiningPeer(jp.id) }) }) }).then((data) =&gt; { let accessData = {key: data.key, url: data.url} this.gate.setOpen(data.socket, accessData) return accessData }) } /** * Prevent clients to join the *WebChannel* even if they possesses a key. */ closeForJoining () { this.gate.close() } /** * If the *WebChannel* is open, the clients can join it through you, otherwise * it is not possible. * @returns {boolean} True if the *WebChannel* is open, false otherwise */ isOpen () { return this.gate.isOpen() } /** * Join the *WebChannel*. * @param {string} key - The key provided by one of the *WebChannel* members. * @param {type} [options] - Any available connection service options. * @returns {Promise} It resolves once you became a *WebChannel* member. */ join (key, options = {}) { let settings = Object.assign({}, this.settings, options) let cBuilder = provide(settings.connector, settings) return new Promise((resolve, reject) =&gt; { this.onJoin = () =&gt; resolve(this) cBuilder.join(key) .then((channel) =&gt; this.initChannel(channel, true)) .catch(reject) }) } /** * Leave the *WebChannel*. No longer can receive and send messages to the group. */ leave () { if (this.channels.size !== 0) { this.manager.broadcast(this, msgBuilder.msg(LEAVE, {id: this.myId})) this.topology = this.settings.topology this.channels.forEach((c) =&gt; { c.close() }) this.channels.clear() this.gate.close() } } /** * Send the message to all *WebChannel* members. * @param {string|external:ArrayBufferView} data - Message */ send (data) { if (this.channels.size !== 0) { msgBuilder.handleUserMessage(data, this.myId, null, (dataChunk) =&gt; { this.manager.broadcast(this, dataChunk) }) } } /** * Send the message to a particular peer in the *WebChannel*. * @param {number} id - Id of the recipient peer * @param {string|external:ArrayBufferView} data - Message */ sendTo (id, data) { if (this.channels.size !== 0) { msgBuilder.handleUserMessage(data, this.myId, id, (dataChunk) =&gt; { this.manager.sendTo(id, this, dataChunk) }, false) } } /** * Get the data which should be provided to all clients who must join * the *WebChannel*. It is the same data which * {@link WebChannel#openForJoining} callback function provides. * @returns {WebChannel~AccessData|null} - Data to join the *WebChannel* * or null is the *WebChannel* is closed */ getAccess () { return this.gate.getAccessData() } /** * Get the ping of the *WebChannel*. It is an amount in milliseconds which * corresponds to the longest ping to each *WebChannel* member. * @returns {Promise} */ ping () { return new Promise((resolve, reject) =&gt; { if (this.pingTime === 0) { this.pingTime = Date.now() this.maxTime = 0 this.pongNb = 0 this.pingFinish = (delay) =&gt; { resolve(delay) } this.manager.broadcast(this, msgBuilder.msg(PING, {senderId: this.myId})) setTimeout(() =&gt; { resolve(PING_TIMEOUT) }, PING_TIMEOUT) } }) } get topology () { return this.settings.topology } /** * Send a message to a service of the same peer, joining peer or any peer in * the *WebChannel*. * @private * @param {string} serviceName - Service name. * @param {string} recepient - Identifier of recepient peer id. * @param {Object} [msg={}] - Message to send. */ sendSrvMsg (serviceName, recepient, msg = {}, channel = null) { let fullMsg = msgBuilder.msg( SERVICE_DATA, {serviceName, recepient, data: Object.assign({}, msg)} ) if (channel !== null) { channel.send(fullMsg) return } if (recepient === this.myId) { this.onChannelMessage(null, fullMsg) } else { // If this function caller is a peer who is joining if (this.isJoining()) { this.getJoiningPeer(this.myId) .intermediaryChannel .send(fullMsg) } else { // If the recepient is a joining peer if (this.hasJoiningPeer(recepient)) { let jp = this.getJoiningPeer(recepient) // If I am an intermediary peer for recepient if (jp.intermediaryId === this.myId) { jp.intermediaryChannel.send(fullMsg) // If not, then send this message to the recepient's intermediary peer } else { this.manager.sendTo(jp.intermediaryId, this, fullMsg) } // If the recepient is a member of webChannel } else { this.manager.sendTo(recepient, this, fullMsg) } } } } /** * Message event handler (*WebChannel* mediator). All messages arrive here first. * @private * @param {Channel} channel - The channel the message came from * @param {external:ArrayBuffer} data - Message */ onChannelMessage (channel, data) { let header = msgBuilder.readHeader(data) if (header.code === USER_DATA) { msgBuilder.readUserMessage(this.id, header.senderId, data, (fullData, isBroadcast) =&gt; { this.onMessage(header.senderId, fullData, isBroadcast) }) } else { let msg = msgBuilder.readInternalMessage(data) switch (header.code) { case LEAVE: for (let c of this.channels) { if (c.peerId === msg.id) { c.close() this.channels.delete(c) } } this.peerNb-- this.onLeaving(msg.id) break case SERVICE_DATA: if (this.myId === msg.recepient) { provide(msg.serviceName, this.settings).onMessage(this, channel, msg.data) } else { this.sendSrvMsg(msg.serviceName, msg.recepient, msg.data) } break case JOIN_INIT: this.topology = msg.manager this.myId = msg.id channel.peerId = msg.intermediaryId this.addJoiningPeer(msg.id, msg.intermediaryId, channel) break case JOIN_NEW_MEMBER: this.addJoiningPeer(msg.id, msg.intermediaryId) break case REMOVE_NEW_MEMBER: this.removeJoiningPeer(msg.id) break case JOIN_FINILIZE: this.joinSuccess(this.myId) // console.log(this.myId + ' JOINED SUCCESSFULLY') this.manager.broadcast(this, msgBuilder.msg(JOIN_SUCCESS, {id: this.myId})) this.onJoin() break case JOIN_SUCCESS: // console.log(this.myId + ' JOIN_SUCCESS from ' + msg.id) this.joinSuccess(msg.id) this.peerNb++ this.onJoining(msg.id) break case INIT_CHANNEL_PONG: channel.onPong() delete channel.onPong break case PING: this.manager.sendTo(msg.senderId, this, msgBuilder.msg(PONG)) break case PONG: let now = Date.now() this.pongNb++ this.maxTime = Math.max(this.maxTime, now - this.pingTime) if (this.pongNb === this.peerNb) { this.pingFinish(this.maxTime) this.pingTime = 0 } break default: throw new Error(`Unknown message type code: &quot;${header.code}&quot;`) } } } /** * Error event handler for each *Channel* in the *WebChannel*. * @private * @param {external:Event} evt - Event */ onChannelError (evt) { console.log('DATA_CHANNEL ERROR: ', evt) } /** * Close event handler for each *Channel* in the *WebChannel*. * @private * @param {external:CloseEvent} closeEvt - Close event */ onChannelClose (closeEvt) { console.log('DATA_CHANNEL CLOSE: ', closeEvt) } set topology (name) { this.settings.topology = name this.manager = provide(this.settings.topology) } /** * Initialize channel. The *Channel* object is a facade for *WebSocket* and * *RTCDataChannel*. * @private * @param {external:WebSocket|external:RTCDataChannel} ch - Channel to * initialize * @param {boolean} isInitiator - Equals to true if this peer is an initiator * in the channel establishment, false otherwise * @param {number} [id] - Assign an id to this channel. It would be generated * if not provided * @returns {Promise} - Resolved once the channel is initialized on both sides */ initChannel (ch, isInitiator, id = -1) { return new Promise((resolve, reject) =&gt; { if (id === -1) { id = this.generateId() } let channel = new Channel(ch, this, id) // TODO: treat the case when the 'ping' or 'pong' message has not been received if (isInitiator) { channel.config() channel.onPong = () =&gt; resolve(channel) ch.send('ping') } else { ch.onmessage = (msgEvt) =&gt; { if (msgEvt.data === 'ping') { channel.config() channel.send(msgBuilder.msg(INIT_CHANNEL_PONG)) resolve(channel) } } } }) } /** * Function to be executed on each peer once the joining peer has joined the * *WebChannel* * @private * @param {number} id Identifier of the recently joined peer */ joinSuccess (id) { let jp = this.getJoiningPeer(id) jp.channelsToAdd.forEach((c) =&gt; { this.channels.add(c) }) // TODO: handle channels which should be closed &amp; removed // this.joiningPeers.delete(jp) } /** * Get joining peer by his id. * @private * @throws Will throws an error if the peer could not be found * @param {number} id Peer id */ getJoiningPeer (id) { // if (this.myId !== id) { // console.log('Me ' + this.myId + ' is looking for ' + id) // } for (let jp of this.joiningPeers) { if (jp.id === id) { return jp } } throw new Error('Peer ' + this.myId + ' could not find the joining peer ' + id) } /** * Get all joining peers. * @private * @returns {external:Set} - Joining peers */ getJoiningPeers () { return this.joiningPeers } /** * Add joining peer. * @private * @param {number} jpId - Joining peer id * @param {number} intermediaryId - The id of the peer through whom the * joining peer joins the *WebChannel* * @param {Channel} [intermediaryChannel] - Intermediary channel bitween the * joining peer and his intermediary peer * @returns {JoiningPeer} - Just added joining peer */ addJoiningPeer (jpId, intermediaryId, intermediaryChannel = null) { // if (this.myId !== jpId) { // console.log('Me ' + this.myId + ' is adding: ' + jpId + ' where intermediaryId is ' + intermediaryId + ' and the channel is ' + (intermediaryChannel !== null)) // } let jp = new JoiningPeer(jpId, intermediaryId, intermediaryChannel) if (this.hasJoiningPeer(jpId)) { throw new Error('Joining peer already exists!') } this.joiningPeers.add(jp) return jp } /** * Remove joining peer from the joining peer list if he exists. It is done when the joining * peer finished the joining process succesfully or not. * @private * @param {number} jpId - Joining peer id */ removeJoiningPeer (jpId) { if (this.hasJoiningPeer(jpId)) { this.joiningPeers.delete(this.getJoiningPeer(jpId)) } } /** * Check whether this peer is about to join the *WebChannel*. * @private * @returns {boolean} - True if this peer is joining the *WebChannel* and false * otherwise */ isJoining () { for (let jp of this.joiningPeers) { if (jp.id === this.myId) { return true } } return false } /** * Verify if this peer knows about specific joining peer. * @private * @param {number} jpId - Joining peer id * @returns {boolean} - True if the peer is present, false if not. */ hasJoiningPeer (jpId) { for (let jp of this.joiningPeers) { if (jp.id === jpId) { return true } } return false } /** * Generate random key which will be used to join the *WebChannel*. * @private * @returns {string} - Generated key */ generateKey () { const MIN_LENGTH = 5 const DELTA_LENGTH = 0 const MASK = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' let result = '' const length = MIN_LENGTH + Math.round(Math.random() * DELTA_LENGTH) for (let i = 0; i &lt; length; i++) { result += MASK[Math.round(Math.random() * (MASK.length - 1))] } return result } /** * Generate random id for a *WebChannel* or a new peer. * @private * @returns {number} - Generated id */ generateId () { let id do { id = Math.ceil(Math.random() * MAX_ID) for (let c of this.channels) { if (id === c.peerId) continue } if (this.hasJoiningPeer(id)) continue if (id === this.myId) continue break } while (true) return id } } export {WebChannel} × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Source: index.js import '../node_modules/webrtc-adapter/out/adapter_no_edge_no_global_es5' export { WEBRTC, FULLY_CONNECTED } from './serviceProvider' export { WebChannel } from './WebChannel' /** * @external JSON * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON} */ /** * @external Error * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Error} */ /** * @external RTCPeerConnection * @see {@link https://developer.mozilla.org/en/docs/Web/API/RTCPeerConnection} */ /** * @external RTCSessionDescription * @see {@link https://developer.mozilla.org/en/docs/Web/API/RTCSessionDescription} */ /** * @external RTCDataChannel * @see {@link https://developer.mozilla.org/en/docs/Web/API/RTCDataChannel} */ /** * @external RTCIceCandidate * @see {@link https://developer.mozilla.org/en/docs/Web/API/RTCIceCandidate} */ /** * @external RTCPeerConnectionIceEvent * @see {@link https://developer.mozilla.org/en/docs/Web/API/RTCPeerConnectionIceEvent} */ /** * @external CloseEvent * @see {@link https://developer.mozilla.org/en/docs/Web/API/CloseEvent/CloseEvent} */ /** * @external WebSocket * @see {@link https://developer.mozilla.org/en/docs/Web/API/WebSocket} */ /** * @external Set * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set} */ /** * @external Map * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Map} */ /** * @external ArrayBufferView * @see {@link https://developer.mozilla.org/en/docs/Web/API/ArrayBufferView} */ /** * @external ArrayBuffer * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer} */ /** * @external String * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String} */ /** * @external Int8Array * @see {@link developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Int8Array} */ /** * @external Uint8Array * @see {@link developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array} */ /** * @external Uint8ClampedArray * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray} */ /** * @external Int16Array * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Int16Array} */ /** * @external Uint16Array * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array} */ /** * @external Int32Array * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Int32Array} */ /** * @external Uint32Array * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array} */ /** * @external Float32Array * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Float32Array} */ /** * @external Float64Array * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Float64Array} */ /** * @external DataView * @see {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/DataView} */ × Search results Close "},"service_channelBuilder_WebRTCService.js.html":{"id":"service_channelBuilder_WebRTCService.js.html","title":"Source: service/channelBuilder/WebRTCService.js","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Source: service/channelBuilder/WebRTCService.js import {ChannelBuilderInterface} from './channelBuilder' /** * Ice candidate event handler. * * @callback WebRTCService~onCandidate * @param {external:RTCPeerConnectionIceEvent} evt - Event. */ /** * Session description event handler. * * @callback WebRTCService~onSDP * @param {external:RTCPeerConnectionIceEvent} evt - Event. */ /** * Data channel event handler. * * @callback WebRTCService~onChannel * @param {external:RTCPeerConnectionIceEvent} evt - Event. */ /** * The goal of this class is to prevent the error when adding an ice candidate * before the remote description has been set. */ class RTCPendingConnections { constructor () { this.connections = new Map() } /** * Prepares pending connection for the specified peer only if it has not been added already. * * @param {string} id - Peer id */ add (id) { if (!this.connections.has(id)) { let pc = null let obj = {promise: null} obj.promise = new Promise((resolve, reject) =&gt; { Object.defineProperty(obj, 'pc', { get: () =&gt; pc, set: (value) =&gt; { pc = value resolve() } }) setTimeout(reject, CONNECT_TIMEOUT, 'timeout') }) this.connections.set(id, obj) } } /** * Remove a pending connection from the Map. Usually when the connection has already * been established and there is now interest to hold this reference. * * @param {string} id - Peer id. */ remove (id) { this.connections.delete(id) } /** * Returns RTCPeerConnection object for the provided peer id. * * @param {string} id - Peer id. * @return {external:RTCPeerConnection} - Peer connection. */ getPC (id) { return this.connections.get(id).pc } /** * Updates RTCPeerConnection reference for the provided peer id. * * @param {string} id - Peer id. * @param {external:RTCPeerConnection} pc - Peer connection. */ setPC (id, pc) { this.connections.get(id).pc = pc } /** * When the remote description is set, it will add the ice candidate to the * peer connection of specified peer. * * @param {string} id - Peer id. * @param {external:RTCIceCandidate} candidate - Ice candidate. * @return {Promise} - Resolved once the ice candidate has been succesfully added. */ addIceCandidate (id, candidate) { let obj = this.connections.get(id) return obj.promise.then(() =&gt; { return obj.pc.addIceCandidate(candidate) }) } } const CONNECT_TIMEOUT = 2000 const connectionsByWC = new Map() /** * Service class responsible to establish connections between peers via * `RTCDataChannel`. * * @see {@link external:RTCPeerConnection} * @extends module:channelBuilder~ChannelBuilderInterface */ class WebRTCService extends ChannelBuilderInterface { /** * WebRTCService constructor. * * @param {Object} [options] - This service options. * @param {Object} [options.signaling='wws://sigver-coastteam.rhcloud.com:8000'] - * Signaling server URL. * @param {Object[]} [options.iceServers=[{urls: 'stun:23.21.150.121'},{urls: 'stun:stun.l.google.com:19302'},{urls: 'turn:numb.viagenie.ca', credential: 'webrtcdemo', username: 'louis%40mozilla.com'}]] - WebRTC options to setup which STUN * and TURN servers to be used. */ constructor (options = {}) { super() this.defaults = { signaling: 'ws://sigver-coastteam.rhcloud.com:8000', iceServers: [ {urls: 'stun:turn01.uswest.xirsys.com'}, {urls: 'turn:turn01.uswest.xirsys.com:443?transport=udp', credential: 'ffd2ac3a-280e-11e6-a490-82fbe4816256', username: 'ffd2abae-280e-11e6-b8e6-4969dd337df0'} ] } this.settings = Object.assign({}, this.defaults, options) } open (key, onChannel, options = {}) { let settings = Object.assign({}, this.settings, options) return new Promise((resolve, reject) =&gt; { let connections = new RTCPendingConnections() let socket try { socket = new window.WebSocket(settings.signaling) } catch (err) { reject(err.message) } // Send a message to signaling server: ready to receive offer socket.onopen = () =&gt; { try { socket.send(JSON.stringify({key})) } catch (err) { reject(err.message) } // TODO: find a better solution than setTimeout. This is for the case when the key already exists and thus the server will close the socket, but it will close it after this function resolves the Promise. setTimeout(resolve, 100, {key, url: settings.signaling, socket}) } socket.onmessage = (evt) =&gt; { let msg = JSON.parse(evt.data) if (!('id' in msg) || !('data' in msg)) { console.log('Unknown message from the signaling server: ' + evt.data) socket.close() return } connections.add(msg.id) if ('offer' in msg.data) { this.createPeerConnectionAndAnswer( (candidate) =&gt; socket.send(JSON.stringify({id: msg.id, data: {candidate}})), (answer) =&gt; socket.send(JSON.stringify({id: msg.id, data: {answer}})), onChannel, msg.data.offer ).then((pc) =&gt; connections.setPC(msg.id, pc)) .catch((reason) =&gt; { console.error(`Answer generation failed: ${reason}`) }) } else if ('candidate' in msg.data) { connections.addIceCandidate( msg.id, this.createIceCandidate(msg.data.candidate) ).catch((reason) =&gt; { console.error(`Adding ice candidate failed: ${reason}`) }) } } socket.onclose = (closeEvt) =&gt; { if (closeEvt.code !== 1000) { console.error(`Socket with signaling server ${settings.signaling} has been closed with code ${closeEvt.code}: ${closeEvt.reason}`) reject(closeEvt.reason) } } }) } join (key, options = {}) { let settings = Object.assign({}, this.settings, options) return new Promise((resolve, reject) =&gt; { let pc // Connect to the signaling server let socket = new WebSocket(settings.signaling) socket.onopen = () =&gt; { // Prepare and send offer this.createPeerConnectionAndOffer( (candidate) =&gt; socket.send(JSON.stringify({data: {candidate}})), (offer) =&gt; socket.send(JSON.stringify({join: key, data: {offer}})), resolve ) .then((peerConnection) =&gt; { pc = peerConnection }) .catch(reject) } socket.onmessage = (evt) =&gt; { try { let msg = JSON.parse(evt.data) console.log('Message from SIGNALING server: ', msg) // Check message format if (!('data' in msg)) { reject(`Unknown message from the signaling server: ${evt.data}`) } if ('answer' in msg.data) { pc.setRemoteDescription(this.createSessionDescription(msg.data.answer)) .then(() =&gt; { console.log('Answer has been set: ', msg.data.answer) }) .catch(reject) } else if ('candidate' in msg.data) { pc.addIceCandidate(this.createIceCandidate(msg.data.candidate)) .then(() =&gt; { console.log('Candidate has been added: ', msg.data.candidate) }) .catch((evt) =&gt; { // This exception does not reject the current Promise, because // still the connection may be established even without one or // several candidates console.error('Adding candidate failed: ', evt) }) } else { reject(`Unknown message from the signaling server: ${evt.data}`) } } catch (err) { reject(err.message) } } socket.onerror = (evt) =&gt; { reject('WebSocket with signaling server error: ' + evt.message) } socket.onclose = (closeEvt) =&gt; { if (closeEvt.code !== 1000) { reject(`Socket with signaling server ${settings.signaling} has been closed with code ${closeEvt.code}: ${closeEvt.reason}`) } } }) } connectMeTo (wc, id) { return new Promise((resolve, reject) =&gt; { let sender = wc.myId let connections = this.getPendingConnections(wc) connections.add(id) this.createPeerConnectionAndOffer( (candidate) =&gt; wc.sendSrvMsg(this.name, id, {sender, candidate}), (offer) =&gt; wc.sendSrvMsg(this.name, id, {sender, offer}), (channel) =&gt; { connections.remove(id) resolve(channel) } ).then((pc) =&gt; connections.setPC(id, pc)) setTimeout(reject, CONNECT_TIMEOUT, 'Timeout') }) } onMessage (wc, channel, msg) { let connections = this.getPendingConnections(wc) connections.add(msg.sender) if ('offer' in msg) { this.createPeerConnectionAndAnswer( (candidate) =&gt; wc.sendSrvMsg(this.name, msg.sender, {sender: wc.myId, candidate}), (answer) =&gt; wc.sendSrvMsg(this.name, msg.sender, {sender: wc.myId, answer}), (channel) =&gt; { wc.initChannel(channel, false, msg.sender) connections.remove(channel.peerId) }, msg.offer ).then((pc) =&gt; { connections.setPC(msg.sender, pc) }) } if ('answer' in msg) { connections.getPC(msg.sender) .setRemoteDescription(this.createSessionDescription(msg.answer)) .catch((reason) =&gt; { console.error('Setting answer error: ' + reason) }) } else if ('candidate' in msg) { connections.addIceCandidate(msg.sender, this.createIceCandidate(msg.candidate)) .catch((reason) =&gt; { console.error('Setting candidate error: ', reason) }) } } /** * Creates a peer connection and generates an SDP offer. * * @param {WebRTCService~onCandidate} onCandidate - Ice candidate event handler. * @param {WebRTCService~onSDP} sendOffer - Session description event handler. * @param {WebRTCService~onChannel} onChannel - Handler event when the data channel is ready. * @return {Promise} - Resolved when the offer has been succesfully created, * set as local description and sent to the peer. */ createPeerConnectionAndOffer (onCandidate, sendOffer, onChannel) { let pc = this.createPeerConnection(onCandidate) let dc = pc.createDataChannel(null) pc.oniceconnectionstatechange = () =&gt; { if (pc.iceConnectionState === 'disconnected') { dc.onclose() } } dc.onopen = (evt) =&gt; { console.log('Data channel has been opened: ', evt) onChannel(dc) } return pc.createOffer() .then((offer) =&gt; pc.setLocalDescription(offer)) .then(() =&gt; { sendOffer(pc.localDescription.toJSON()) return pc }) } /** * Creates a peer connection and generates an SDP answer. * * @param {WebRTCService~onCandidate} onCandidate - Ice candidate event handler. * @param {WebRTCService~onSDP} sendOffer - Session description event handler. * @param {WebRTCService~onChannel} onChannel - Handler event when the data channel is ready. * @param {Object} offer - Offer received from a peer. * @return {Promise} - Resolved when the offer has been succesfully created, * set as local description and sent to the peer. */ createPeerConnectionAndAnswer (onCandidate, sendAnswer, onChannel, offer) { let pc = this.createPeerConnection(onCandidate) pc.ondatachannel = (dcEvt) =&gt; { console.log('ondatachannel: ', dcEvt) let dc = dcEvt.channel pc.oniceconnectionstatechange = () =&gt; { if (pc.iceConnectionState === 'disconnected') { dc.onclose() } } dc.onopen = (evt) =&gt; { console.log('Data channel has been opened: ', evt) onChannel(dc) } } return pc.setRemoteDescription(this.createSessionDescription(offer)) .then(() =&gt; { console.log('Offer has been set: ', offer) return pc.createAnswer() }) .then((answer) =&gt; { console.log('Local description has been set: ', answer) pc.setLocalDescription(answer) }) .then(() =&gt; { console.log('answer has been sent: ', pc.localDescription.toJSON()) sendAnswer(pc.localDescription.toJSON()) return pc }) .catch((reason) =&gt; { console.error('Set offer, generate answer error: ', reason) }) } /** * Creates an instance of `RTCPeerConnection` and sets `onicecandidate` event handler. * * @private * @param {WebRTCService~onCandidate} onCandidate - Ice * candidate event handler. * @return {external:RTCPeerConnection} - Peer connection. */ createPeerConnection (onCandidate) { let pc = new RTCPeerConnection({iceServers: this.settings.iceServers}) pc.onicecandidate = (evt) =&gt; { if (evt.candidate !== null) { let candidate = { candidate: evt.candidate.candidate, sdpMLineIndex: evt.candidate.sdpMLineIndex } onCandidate(candidate) } } return pc } /** * Creates an instance of `RTCIceCandidate`. * * @private * @param {Object} candidate - Candidate object created in * {@link WebRTCService#createPeerConnection}. * @param {} candidate.candidate * @param {} candidate.sdpMLineIndex * @return {external:RTCIceCandidate} - Ice candidate. */ createIceCandidate (candidate) { return new RTCIceCandidate(candidate) } /** * Creates an instance of `RTCSessionDescription`. * * @private * @param {Object} sd - An offer or an answer created by WebRTC API. * @param {} sd.type * @param {} sd.sdp * @return {external:RTCSessionDescription} - Session description. */ createSessionDescription (sd) { return Object.assign(new RTCSessionDescription(), sd) } getPendingConnections (wc) { if (connectionsByWC.has(wc.id)) { return connectionsByWC.get(wc.id) } else { let connections = new RTCPendingConnections() connectionsByWC.set(wc.id, connections) return connections } } } export default WebRTCService × Search results Close "},"service_channelBuilder_channelBuilder.js.html":{"id":"service_channelBuilder_channelBuilder.js.html","title":"Source: service/channelBuilder/channelBuilder.js","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Source: service/channelBuilder/channelBuilder.js import {ServiceInterface} from '../service' /** * Channel Builder module is responsible to create a connection between two * peers. * @module channelBuilder * @see Channel */ /** * On channel callback for {@link module:channelBuilder~ChannelBuilderInterface#open} * function. * * @callback module:channelBuilder~onChannelCallback * @param {Channel} channel - A new channel. */ /** * Call back to initialize the channel. It should be executed on both peer * sides during connection establishment to assure that both channels would be * ready to be used in the web channel. * * @callback module:channelBuilder~initChannel * @param {Channel} ch - Channel. * @param {string} id - Unique channel identifier. */ /** * Interface to be implemented by each connection service. * * @interface * @extends module:service~ServiceInterface */ class ChannelBuilderInterface extends ServiceInterface { constructor () { super() } /** * Enables other clients to establish a connection with you. * * @abstract * @param {string} key - The unique identifier which has to be passed to the * peers who need to connect to you. * @param {module:channelBuilder~ChannelBuilderInterface~onChannelCallback} onChannel - Callback * function to execute once the connection has been established. * @param {Object} [options] - Any other options which depend on the service implementation. * @return {Promise} - Once resolved, provide an Object with `key` and `url` * attributes to be passed to {@link module:channelBuilder~ChannelBuilderInterface#join} function. * It is rejected if an error occured. */ open (key, onChannel, options) { throw new Error('Must be implemented by subclass!') } /** * Connects you with the peer who provided the `key`. * * @abstract * @param {string} key - A key obtained from the peer who executed * {@link module:channelBuilder~ChannelBuilderInterface#open} function. * @param {Object} [options] Any other options which depend on the implementation. * @return {Promise} It is resolved when the connection is established, otherwise it is rejected. */ join (key, options) { throw new Error('Must be implemented by subclass!') } /** * Establish a connection between you and another peer (including joining peer) via web channel. * * @abstract * @param {WebChannel} wc - Web Channel through which the connection will be established. * @param {string} id - Peer id with whom you will be connected. * @return {Promise} - Resolved once the connection has been established, rejected otherwise. */ connectMeTo (wc, id) { throw new Error('Must be implemented by subclass!') } } export { /** @see module:channelBuilder~ChannelBuilderInterface */ ChannelBuilderInterface } × Search results Close "},"service_messageBuilder.js.html":{"id":"service_messageBuilder.js.html","title":"Source: service/messageBuilder.js","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Source: service/messageBuilder.js /** * Message builder module is responsible to build messages to send them over the * *WebChannel* and treat messages received by the *WebChannel*. It also manage * big messages (more then 16ko) sent by users. Internal messages are always less * 16ko. * * @module messageBuilder */ import {ServiceInterface} from './service' /** * Maximum message size sent over *Channel*. * @type {number} */ const MAX_MSG_SIZE = 16384 /** * Maximum user message size sent over *Channel*. Is meant without metadata. * @type {number} */ const MAX_USER_MSG_SIZE = 16365 /** * User message offset in the array buffer. All data before are metadata. * @type {number} */ const USER_MSG_OFFSET = 19 /** * First index in the array buffer after header (which is the part of metadata). * @type {number} */ const HEADER_END_OFFSET = 9 /** * Maximum message id number. * @type {number} */ const MAX_MSG_ID_SIZE = 65535 /** * User allowed message type: {@link external:ArrayBuffer} * @type {number} */ const ARRAY_BUFFER_TYPE = 1 /** * User allowed message type: {@link external:Uint8Array} * @type {number} */ const U_INT_8_ARRAY_TYPE = 2 /** * User allowed message type: {@link external:String} * @type {number} */ const STRING_TYPE = 3 /** * User allowed message type: {@link external:Int8Array} * @type {number} */ const INT_8_ARRAY_TYPE = 4 /** * User allowed message type: {@link external:Uint8ClampedArray} * @type {number} */ const U_INT_8_CLAMPED_ARRAY_TYPE = 5 /** * User allowed message type: {@link external:Int16Array} * @type {number} */ const INT_16_ARRAY_TYPE = 6 /** * User allowed message type: {@link external:Uint16Array} * @type {number} */ const U_INT_16_ARRAY_TYPE = 7 /** * User allowed message type: {@link external:Int32Array} * @type {number} */ const INT_32_ARRAY_TYPE = 8 /** * User allowed message type: {@link external:Uint32Array} * @type {number} */ const U_INT_32_ARRAY_TYPE = 9 /** * User allowed message type: {@link external:Float32Array} * @type {number} */ const FLOAT_32_ARRAY_TYPE = 10 /** * User allowed message type: {@link external:Float64Array} * @type {number} */ const FLOAT_64_ARRAY_TYPE = 11 /** * User allowed message type: {@link external:DataView} * @type {number} */ const DATA_VIEW_TYPE = 12 /** * Buffer for big user messages. */ const buffers = new Map() /** * Message builder service class. */ class MessageBuilderService extends ServiceInterface { /** * @callback MessageBuilderService~Send * @param {external:ArrayBuffer} dataChunk - If the message is too big this * action would be executed for each data chunk until send whole message */ /** * @callback MessageBuilderService~Receive * @param {external:ArrayBuffer|external:Uint8Array|external:String| * external:Int8Array|external:Uint8ClampedArray|external:Int16Array| * external:Uint16Array|external:Int32Array|external:Uint32Array| * external:Float32Array|external:Float64Array|external:DataView} data - Message. * Its type depends on what other */ /** * Header of the metadata of the messages sent/received over the *WebChannel*. * @typedef {Object} MessageBuilderService~Header * @property {number} code - Message type code * @property {number} senderId - Id of the sender peer * @property {number} recipientId - Id of the recipient peer */ constructor () { super() } /** * Prepare user message to be sent over the *WebChannel* * @param {external:ArrayBuffer|external:Uint8Array|external:String| * external:Int8Array|external:Uint8ClampedArray|external:Int16Array| * external:Uint16Array|external:Int32Array|external:Uint32Array| * external:Float32Array|external:Float64Array|external:DataView} data - * Message to be sent * @param {number} senderId - Id of the peer who sends this message * @param {number} recipientId - Id of the recipient peer * @param {MessageBuilderService~Send} action - Send callback executed for each * data chunk if the message is too big * @param {boolean} isBroadcast - Equals to true if this message would be * sent to all *WebChannel* members and false if only to one member */ handleUserMessage (data, senderId, recipientId, action, isBroadcast = true) { let workingData = this.userDataToType(data) let dataUint8Array = workingData.content if (dataUint8Array.byteLength &lt;= MAX_USER_MSG_SIZE) { let dataView = this.writeHeader(1, senderId, recipientId, dataUint8Array.byteLength + USER_MSG_OFFSET ) dataView.setUint32(HEADER_END_OFFSET, dataUint8Array.byteLength) dataView.setUint8(13, workingData.type) dataView.setUint8(14, isBroadcast ? 1 : 0) let resultUint8Array = new Uint8Array(dataView.buffer) resultUint8Array.set(dataUint8Array, USER_MSG_OFFSET) action(resultUint8Array.buffer) } else { const msgId = Math.ceil(Math.random() * MAX_MSG_ID_SIZE) const totalChunksNb = Math.ceil(dataUint8Array.byteLength / MAX_USER_MSG_SIZE) for (let chunkNb = 0; chunkNb &lt; totalChunksNb; chunkNb++) { let currentChunkMsgByteLength = Math.min( MAX_USER_MSG_SIZE, dataUint8Array.byteLength - MAX_USER_MSG_SIZE * chunkNb ) let dataView = this.writeHeader( 1, senderId, recipientId, USER_MSG_OFFSET + currentChunkMsgByteLength ) dataView.setUint32(9, dataUint8Array.byteLength) dataView.setUint8(13, workingData.type) dataView.setUint8(14, isBroadcast ? 1 : 0) dataView.setUint16(15, msgId) dataView.setUint16(17, chunkNb) let resultUint8Array = new Uint8Array(dataView.buffer) let j = USER_MSG_OFFSET let startIndex = MAX_USER_MSG_SIZE * chunkNb let endIndex = startIndex + currentChunkMsgByteLength for (let i = startIndex; i &lt; endIndex; i++) { resultUint8Array[j++] = dataUint8Array[i] } action(resultUint8Array.buffer) } } } /** * Build a message which can be then sent trough the *Channel*. * @param {number} code - One of the internal message type code (e.g. {@link * USER_DATA}) * @param {Object} [data={}] - Message. Could be empty if the code is enough * @returns {external:ArrayBuffer} - Built message */ msg (code, data = {}) { let msgEncoded = (new TextEncoder()).encode(JSON.stringify(data)) let msgSize = msgEncoded.byteLength + HEADER_END_OFFSET let dataView = this.writeHeader(code, null, null, msgSize) let fullMsg = new Uint8Array(dataView.buffer) fullMsg.set(msgEncoded, HEADER_END_OFFSET) return fullMsg.buffer } /** * Read user message which was prepared by another peer with * {@link MessageBuilderService#handleUserMessage} and sent. * @param {number} wcId - *WebChannel* identifier * @param {number} senderId - Id of the peer who sent this message * @param {external:ArrayBuffer} data - Message * @param {MessageBuilderService~Receive} action - Callback when the message is * ready */ readUserMessage (wcId, senderId, data, action) { let dataView = new DataView(data) let msgSize = dataView.getUint32(HEADER_END_OFFSET) let dataType = dataView.getUint8(13) let isBroadcast = dataView.getUint8(14) if (msgSize &gt; MAX_USER_MSG_SIZE) { let msgId = dataView.getUint16(15) let chunk = dataView.getUint16(17) let buffer = this.getBuffer(wcId, senderId, msgId) if (buffer === undefined) { this.setBuffer(wcId, senderId, msgId, new Buffer(msgSize, data, (fullData) =&gt; { action(this.extractUserData(fullData, dataType), isBroadcast) }) ) } else { buffer.add(data, chunk) } } else { let dataArray = new Uint8Array(data) let userData = new Uint8Array(data.byteLength - USER_MSG_OFFSET) let j = USER_MSG_OFFSET for (let i in userData) { userData[i] = dataArray[j++] } action(this.extractUserData(userData.buffer, dataType), isBroadcast) } } /** * Read internal Netflux message. * @param {external:ArrayBuffer} data - Message * @returns {Object} */ readInternalMessage (data) { let uInt8Array = new Uint8Array(data) return JSON.parse((new TextDecoder()) .decode(uInt8Array.subarray(HEADER_END_OFFSET, uInt8Array.byteLength)) ) } /** * Extract header from the message. Each user message has a header which is * a part of the message metadata. * TODO: add header also to the internal messages. * @param {external:ArrayBuffer} data - Whole message * @returns {MessageBuilderService~Header} */ readHeader (data) { let dataView = new DataView(data) return { code: dataView.getUint8(0), senderId: dataView.getUint32(1), recepientId: dataView.getUint32(5) } } /** * Create an *ArrayBuffer* and fill in the header. * @private * @param {number} code - Message type code * @param {number} senderId - Sender peer id * @param {number} recipientId - Recipient peer id * @param {number} dataSize - Message size in bytes * @return {external:DataView} - Data view with initialized header */ writeHeader (code, senderId, recipientId, dataSize) { let dataView = new DataView(new ArrayBuffer(dataSize)) dataView.setUint8(0, code) dataView.setUint32(1, senderId) dataView.setUint32(5, recipientId) return dataView } /** * Netflux sends data in *ArrayBuffer*, but the user can send data in different * types. This function retrieve the inital message sent by the user. * @private * @param {external:ArrayBuffer} - Message as it was received by the *WebChannel* * @param {number} - Message type as it was defined by the user * @returns {external:ArrayBuffer|external:Uint8Array|external:String| * external:Int8Array|external:Uint8ClampedArray|external:Int16Array| * external:Uint16Array|external:Int32Array|external:Uint32Array| * external:Float32Array|external:Float64Array|external:DataView} - Initial * user message */ extractUserData (buffer, type) { switch (type) { case ARRAY_BUFFER_TYPE: return buffer case U_INT_8_ARRAY_TYPE: return new Uint8Array(buffer) case STRING_TYPE: return new TextDecoder().decode(new Uint8Array(buffer)) case INT_8_ARRAY_TYPE: return new Int8Array(buffer) case U_INT_8_CLAMPED_ARRAY_TYPE: return new Uint8ClampedArray(buffer) case INT_16_ARRAY_TYPE: return new Int16Array(buffer) case U_INT_16_ARRAY_TYPE: return new Uint16Array(buffer) case INT_32_ARRAY_TYPE: return new Int32Array(buffer) case U_INT_32_ARRAY_TYPE: return new Uint32Array(buffer) case FLOAT_32_ARRAY_TYPE: return new Float32Array(buffer) case FLOAT_64_ARRAY_TYPE: return new Float64Array(buffer) case DATA_VIEW_TYPE: return new DataView(buffer) } } /** * Identify the user message type. * @private * @param {external:ArrayBuffer|external:Uint8Array|external:String| * external:Int8Array|external:Uint8ClampedArray|external:Int16Array| * external:Uint16Array|external:Int32Array|external:Uint32Array| * external:Float32Array|external:Float64Array|external:DataView} - User message * @returns {number} - User message type */ userDataToType (data) { let result = {} if (data instanceof ArrayBuffer) { result.type = ARRAY_BUFFER_TYPE result.content = new Uint8Array(data) } else if (data instanceof Uint8Array) { result.type = U_INT_8_ARRAY_TYPE result.content = data } else if (typeof data === 'string' || data instanceof String) { result.type = STRING_TYPE result.content = new TextEncoder().encode(data) } else { result.content = new Uint8Array(data.buffer) if (data instanceof Int8Array) { result.type = INT_8_ARRAY_TYPE } else if (data instanceof Uint8ClampedArray) { result.type = U_INT_8_CLAMPED_ARRAY_TYPE } else if (data instanceof Int16Array) { result.type = INT_16_ARRAY_TYPE } else if (data instanceof Uint16Array) { result.type = U_INT_16_ARRAY_TYPE } else if (data instanceof Int32Array) { result.type = INT_32_ARRAY_TYPE } else if (data instanceof Uint32Array) { result.type = U_INT_32_ARRAY_TYPE } else if (data instanceof Float32Array) { result.type = FLOAT_32_ARRAY_TYPE } else if (data instanceof Float64Array) { result.type = FLOAT_64_ARRAY_TYPE } else if (data instanceof DataView) { result.type = DATA_VIEW_TYPE } else { throw new Error('Unknown data object') } } return result } /** * Get the buffer. * @private * @param {number} wcId - *WebChannel* id * @param {number} peerId - Peer id * @param {number} msgId - Message id * @returns {Buffer|undefined} - Returns buffer if it was found and undefined * if not */ getBuffer (wcId, peerId, msgId) { let wcBuffer = buffers.get(wcId) if (wcBuffer !== undefined) { let peerBuffer = wcBuffer.get(peerId) if (peerBuffer !== undefined) { return peerBuffer.get(msgId) } } return undefined } /** * Add a new buffer to the buffer array. * @private * @param {number} wcId - *WebChannel* id * @param {number} peerId - Peer id * @param {number} msgId - Message id * @param {Buffer} - buffer */ setBuffer (wcId, peerId, msgId, buffer) { let wcBuffer = buffers.get(wcId) if (wcBuffer === undefined) { wcBuffer = new Map() buffers.set(wcId, wcBuffer) } let peerBuffer = wcBuffer.get(peerId) if (peerBuffer === undefined) { peerBuffer = new Map() wcBuffer.set(peerId, peerBuffer) } peerBuffer.set(msgId, buffer) } } /** * Buffer class used when the user message exceeds the message size limit which * may be sent over a *Channel*. Each buffer is identified by *WebChannel* id, * peer id (who sends the big message) and message id (in case if the peer sends * more then 1 big message at a time). */ class Buffer { /** * @callback Buffer~onFullMessage * @param {external:ArrayBuffer} - The full message as it was initially sent * by user */ /** * @param {number} fullDataSize - The total user message size * @param {external:ArrayBuffer} - The first chunk of the user message * @param {Buffer~onFullMessage} action - Callback to be executed when all * message chunks are received and thus the message is ready */ constructor (fullDataSize, data, action) { this.fullData = new Uint8Array(fullDataSize) this.currentSize = 0 this.action = action this.add(data, 0) } /** * Add a chunk of message to the buffer. * @param {external:ArrayBuffer} data - Message chunk * @param {number} chunkNb - Number of the chunk */ add (data, chunkNb) { let dataChunk = new Uint8Array(data) let dataChunkSize = data.byteLength this.currentSize += dataChunkSize - USER_MSG_OFFSET let index = chunkNb * MAX_USER_MSG_SIZE for (let i = USER_MSG_OFFSET; i &lt; dataChunkSize; i++) { this.fullData[index++] = dataChunk[i] } if (this.currentSize === this.fullData.byteLength) { this.action(this.fullData.buffer) } } } export {MessageBuilderService, MAX_MSG_SIZE, MAX_USER_MSG_SIZE, USER_MSG_OFFSET, HEADER_END_OFFSET} × Search results Close "},"service_service.js.html":{"id":"service_service.js.html","title":"Source: service/service.js","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Source: service/service.js /** * Service module includes {@link module:channelBuilder}, * {@link module:webChannelManager} and {@link module:messageBuilder}. * Services are substitutable stateless objects. Each service is identified by * its class name and some of them can receive messages via `WebChannel` sent * by another service. * * @module service * @see module:channelBuilder * @see module:webChannelManager * @see module:messageBuilder */ /** * Each service must implement this interface. * @interface */ class ServiceInterface { /** * Service name which corresponds to its class name. * @return {string} - Name */ get name () { return this.constructor.name } } export { /** @see module:service~ServiceInterface */ ServiceInterface } × Search results Close "},"service_webChannelManager_FullyConnectedService.js.html":{"id":"service_webChannelManager_FullyConnectedService.js.html","title":"Source: service/webChannelManager/FullyConnectedService.js","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Source: service/webChannelManager/FullyConnectedService.js import {WebChannelManagerInterface} from './webChannelManager' /** * Fully connected web channel manager. Implements fully connected topology * network, when each peer is connected to each other. * * @extends module:webChannelManager~WebChannelManagerInterface */ class FullyConnectedService extends WebChannelManagerInterface { constructor () { super() } add (channel) { let wc = channel.webChannel let peerIds = new Set([wc.myId]) let jpIds = new Set() wc.channels.forEach((c) =&gt; peerIds.add(c.peerId)) wc.getJoiningPeers().forEach((jp) =&gt; { if (channel.peerId !== jp.id &amp;&amp; !peerIds.has(jp.id)) { jpIds.add(jp.id) } }) return this.connectWith(wc, channel.peerId, channel.peerId, [...peerIds], [...jpIds]) } broadcast (webChannel, data) { for (let c of webChannel.channels) { c.send(data) } } sendTo (id, webChannel, data) { for (let c of webChannel.channels) { if (c.peerId === id) { c.send(data) return } } } leave (webChannel) {} } export default FullyConnectedService × Search results Close "},"service_webChannelManager_webChannelManager.js.html":{"id":"service_webChannelManager_webChannelManager.js.html","title":"Source: service/webChannelManager/webChannelManager.js","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Source: service/webChannelManager/webChannelManager.js import {ServiceInterface} from '../service' import {provide} from '../../serviceProvider' /** * Web Channel Manager module is a submodule of {@link module:service} and the * main component of any Web Channel. It is responsible to preserve Web Channel * structure intact (i.e. all peers have the same vision of the Web Channel). * Among its duties are: * * - Add a new peer into Web Channel. * - Remove a peer from Web Channel. * - Send a broadcast message. * - Send a message to a particular peer. * * @module webChannelManager * @see FullyConnectedService */ /** * Connection service of the peer who received a message of this type should * establish connection with one or several peers. */ const CONNECT_WITH = 1 const CONNECT_WITH_FEEDBACK = 2 const THIS_CHANNEL_TO_JOINING_PEER = 3 const CONNECT_WITH_TIMEOUT = 5000 /** * Each Web Channel Manager Service must implement this interface. * @interface * @extends module:service~ServiceInterface */ class WebChannelManagerInterface extends ServiceInterface { constructor () { super() } onMessage (wc, channel, msg) { let cBuilder = provide(wc.settings.connector, wc.settings) switch (msg.code) { case CONNECT_WITH: if (wc.isJoining()) { msg.joiningPeers.forEach((jp) =&gt; { wc.addJoiningPeer(jp.jpId, jp.intermediaryId) msg.peerIds.push(jp.jpId) }) } // console.log('Me ' + wc.myId + ' should connect to ----&gt; ', msg.peerIds) msg.peerIds = this.reUseIntermediaryChannelIfPossible(wc, msg.jpId, msg.peerIds) let failed = [] if (msg.peerIds.length === 0) { wc.sendSrvMsg(this.name, msg.sender, {code: CONNECT_WITH_FEEDBACK, id: wc.myId, failed} ) } else { // console.log('Me ' + wc.myId + ' should connect to ----&gt; ' + msg.peerIds + '--reUseIntermediaryChannelIfPossible') let counter = 0 msg.peerIds.forEach((id) =&gt; { cBuilder.connectMeTo(wc, id) .then((channel) =&gt; { return wc.initChannel(channel, true, id) }) .then((channel) =&gt; { // console.log('PEER ' + wc.myId + ' CONNECTED TO ' + channel.peerId) counter++ let jp = wc.getJoiningPeer(msg.jpId) jp.toAddList(channel) wc.sendSrvMsg(this.name, channel.peerId, {code: THIS_CHANNEL_TO_JOINING_PEER, jpId: msg.jpId, intermediaryId: jp.intermediaryId, toBeAdded: true}, channel ) if (counter === msg.peerIds.length) { wc.sendSrvMsg(this.name, msg.sender, {code: CONNECT_WITH_FEEDBACK, id: wc.myId, failed} ) } }) .catch((reason) =&gt; { counter++ failed.push({id, reason}) if (counter === msg.peerIds.length) { wc.sendSrvMsg(this.name, msg.sender, {code: CONNECT_WITH_FEEDBACK, id: wc.myId, failed} ) } }) }) } break case CONNECT_WITH_FEEDBACK: wc.connectWithRequests.get(msg.id)(true) break case THIS_CHANNEL_TO_JOINING_PEER: let jp if (wc.hasJoiningPeer(msg.jpId)) { jp = wc.getJoiningPeer(msg.jpId) } else { jp = wc.addJoiningPeer(msg.jpId, msg.intermediaryId) } if (msg.toBeAdded) { jp.toAddList(channel) } else { jp.toRemoveList(channel) } break } } /** * Send a request to a peer asking him to establish a connection with some * peers. This function is used when a new peer is joining the *WebChannel*. * The request can be sent to the peer who is joining as well as other peers * who are already members of the *WebChannel*. * * @param {WebChannel} wc - The Web Channel. * @param {string} id - Id of the peer who will receive this request. * @param {string} jpId - Joining peer id (it is possible that `id`=`jpId`). * @param {string[]} peerIds - Ids of peers with whom `id` peer must established * connections. * @return {Promise} - Is resolved once some of the connections could be established. It is rejected when an error occured. */ connectWith (wc, id, jpId, peerIds, jpIds) { let joiningPeers = [] jpIds.forEach((id) =&gt; { let jp = wc.getJoiningPeer(id) joiningPeers.push({ jpId: jp.id, intermediaryId: jp.intermediaryId }) }) wc.sendSrvMsg(this.name, id, {code: CONNECT_WITH, jpId: jpId, sender: wc.myId, peerIds, joiningPeers} ) return new Promise((resolve, reject) =&gt; { wc.connectWithRequests.set(id, (isDone) =&gt; { if (isDone) { resolve() } else { reject() } }) setTimeout(() =&gt; { reject('CONNECT_WITH_TIMEOUT') }, this.calculateConnectWithTimeout(peerIds.length)) }) } calculateConnectWithTimeout (nbPeers) { if (nbPeers &gt; 0) { return CONNECT_WITH_TIMEOUT + Math.log10(nbPeers) } else { return CONNECT_WITH_TIMEOUT } } reUseIntermediaryChannelIfPossible (wc, jpId, ids) { let intermidiaryChannel let peerIndex for (let jp of wc.getJoiningPeers()) { if (jp.intermediaryChannel !== null) { peerIndex = ids.indexOf(jp.intermediaryId) if (peerIndex === -1) { peerIndex = ids.indexOf(jp.id) } if (peerIndex !== -1) { intermidiaryChannel = jp.intermediaryChannel break } } } let jp = wc.getJoiningPeer(jpId) jp.toAddList(intermidiaryChannel) wc.sendSrvMsg(this.name, jp.intermediaryId, {code: THIS_CHANNEL_TO_JOINING_PEER, jpId, intermediaryId: jp.intermediaryId, toBeAdded: true}, intermidiaryChannel ) ids.splice(peerIndex, 1) return ids } /** * Adds a new peer into Web Channel. * * @abstract * @param {Channel} ch - Channel to be added (it should has * the `webChannel` property). * @return {Promise} - Resolved once the channel has been succesfully added, * rejected otherwise. */ add (ch) { throw new Error('Must be implemented by subclass!') } /** * Send a message to all peers in Web Channel. * * @abstract * @param {WebChannel} wc - Web Channel where the message will be propagated. * @param {string} data - Data in stringified JSON format to be send. */ broadcast (wc, data) { throw new Error('Must be implemented by subclass!') } /** * Send a message to a particular peer in Web Channel. * * @abstract * @param {string} id - Peer id. * @param {WebChannel} wc - Web Channel where the message will be propagated. * @param {string} data - Data in stringified JSON format to be send. */ sendTo (id, wc, data) { throw new Error('Must be implemented by subclass!') } /** * Leave Web Channel. * * @abstract * @param {WebChannel} wc - Web Channel to leave. */ leave (wc) { throw new Error('Must be implemented by subclass!') } } export { /** @see module:webChannelManager~WebChannelManagerInterface */ WebChannelManagerInterface } × Search results Close "},"serviceProvider.js.html":{"id":"serviceProvider.js.html","title":"Source: serviceProvider.js","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Source: serviceProvider.js import FullyConnectedService from './service/webChannelManager/FullyConnectedService' import WebRTCService from './service/channelBuilder/WebRTCService' import {MessageBuilderService} from './service/messageBuilder' /** * Service Provider module is a helper module for {@link module:service}. It is * responsible to instantiate all services. This module must be used to get * any service instance. * @module serviceProvider */ /** * Constant used to get an instance of {@link WebRTCService}. * @type {string} */ const WEBRTC = 'WebRTCService' /** * Constant used to get an instance of {@link FullyConnectedService}. It is a * singleton service. * @type {string} */ const FULLY_CONNECTED = 'FullyConnectedService' /** * Constant used to get an instance of {@link MessageBuilderService}. It is a * singleton service. * @type {string} */ const MESSAGE_BUILDER = 'MessageBuilderService' /** * Contains services who are singletons. * @type {string} */ const services = new Map() /** * Provides the service instance specified by `name`. * * @param {(module:serviceProvider.MESSAGE_BUILDER| * module:serviceProvider.WEBRTC| * module:serviceProvider.FULLY_CONNECTED)} name - The service name. * @param {Object} [options] - Any options that the service accepts. * @return {module:service~ServiceInterface} - Service instance. * @throws An error if the service name is unknown */ let provide = function (name, options = {}) { if (services.has(name)) { return services.get(name) } let service switch (name) { case WEBRTC: return new WebRTCService(options) case FULLY_CONNECTED: service = new FullyConnectedService() services.set(name, service) return service case MESSAGE_BUILDER: service = new MessageBuilderService() services.set(name, service) return service default: throw new Error(`Unknown service name: &quot;${name}&quot;`) } } export {WEBRTC, FULLY_CONNECTED, MESSAGE_BUILDER, provide} × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Global Members &lt;constant&gt; MAX_ID :number Maximum identifier number for WebChannel#generateId function. Type: number Source: WebChannel.js, line 11 &lt;constant&gt; PING_TIMEOUT :number Timout for ping WebChannel in milliseconds. Type: number Source: WebChannel.js, line 17 &lt;constant&gt; USER_DATA :number One of the internal message type. It's a peer message. Type: number Source: WebChannel.js, line 23 &lt;constant&gt; SERVICE_DATA :number One of the internal message type. This message should be threated by a specific service class. Type: number Source: WebChannel.js, line 30 &lt;constant&gt; LEAVE :number One of the internal message type. Means a peer has left the WebChannel. Type: number Source: WebChannel.js, line 36 &lt;constant&gt; JOIN_INIT :number One of the internal message type. Initialization message for the joining peer. Type: number Source: WebChannel.js, line 43 &lt;constant&gt; JOIN_NEW_MEMBER :number One of the internal message type. The message is intended for the WebChannel members to notify them about the joining peer. Type: number Source: WebChannel.js, line 50 &lt;constant&gt; REMOVE_NEW_MEMBER :number One of the internal message type. The message is intended for the WebChannel members to notify them that the joining peer has not succeed. Type: number Source: WebChannel.js, line 57 &lt;constant&gt; JOIN_FINILIZE :number One of the internal message type. The message is intended for the joining peer to notify him that everything is ready and he may join the WebChannel. Type: number Source: WebChannel.js, line 64 &lt;constant&gt; JOIN_SUCCESS :number One of the internal message type. The message sent by the joining peer to notify all WebChannel members about his arrivel. Type: number Source: WebChannel.js, line 71 &lt;constant&gt; INIT_CHANNEL_PONG :number One of the internal message type. This message is sent during Initialization of a channel. Type: number Source: WebChannel.js, line 79 See: WebChannel#initChannel &lt;constant&gt; PING :number One of the internal message type. Ping message. Type: number Source: WebChannel.js, line 85 &lt;constant&gt; PONG :number One of the internal message type. Pong message, response to the ping message. Type: number Source: WebChannel.js, line 91 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Modules Classes Channel JoiningPeer WebChannelGate WebChannel RTCPendingConnections WebRTCService MessageBuilderService Buffer FullyConnectedService × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Classes Classes Channel JoiningPeer WebChannelGate WebChannel RTCPendingConnections WebRTCService MessageBuilderService Buffer FullyConnectedService × Search results Close "},"interfaces.list.html":{"id":"interfaces.list.html","title":"Interfaces","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Interfaces Classes Channel JoiningPeer WebChannelGate WebChannel RTCPendingConnections WebRTCService MessageBuilderService Buffer FullyConnectedService × Search results Close "},"externals.list.html":{"id":"externals.list.html","title":"Externals","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Externals Classes Channel JoiningPeer WebChannelGate WebChannel RTCPendingConnections WebRTCService MessageBuilderService Buffer FullyConnectedService × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Abstract peer to peer client transport API. Implementations based on WebRTC and WebSocket to be done. Documentation: https://coast-team.github.io/netflux RemarkWhen using API, it may not work from the first attempt. This is because WebRTC uses ws://sigver-coastteam.rhcloud.com:8000 signaling server by default. Due to the rhcloud application hosting specification, following a period of inactivity, the server will be available after a while. Try it again a few seconds later. Supported browsersChrome 49 and above Firefox 45 and above API specification (warning: alpha state)RemarksPerhaps WebChannel.openForJoining and WebChannel.closeForJoining could be used in case of WebRTC and WebSocket. Maybe leave the possibility to the API user to decide either is an invite-only WebChannel or not. Lets implement and see. WebChannel See http://coast-team.github.io/netflux/WebChannel.html UML The Green and green/red parts (Facade, WebChannel and Peer) is what we consider to expose to the API user). The Gray parts represent some of internal elements of the API. The White parts are not yet implemented. × Search results Close "},"Channel.html":{"id":"Channel.html","title":"Class: Channel","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Class: Channel Channel Wrapper class for external:RTCDataChannel and external:WebSocket. new Channel(channel, webChannel, peerId) Creates Channel instance from existing data channel or web socket, assigns it to the specified WebChannel and gives him an identifier. Parameters: Name Type Description channel external:WebSocket | external:RTCDataChannel Data channel or web socket webChannel WebChannel The WebChannel this channel will be part of peerId number Identifier of the peer who is at the other end of this channel Source: Channel.js, line 5 Members &lt;private&gt; channel :external:WebSocket|external:RTCDataChannel Data channel or web socket. Type: external:WebSocket | external:RTCDataChannel Source: Channel.js, line 25 webChannel :WebChannel The WebChannel which this channel belongs to. Type: WebChannel Source: Channel.js, line 31 peerId :WebChannel Identifier of the peer who is at the other end of this channel Type: WebChannel Source: Channel.js, line 37 Methods config() Configure this channel. Set up message, error and close event handlers. Source: Channel.js, line 43 send(data) Send message over this channel. The message should be prepared beforhand by the MessageBuilderService Parameters: Name Type Description data extternal:ArrayBuffer Message Source: Channel.js, line 55 See: MessageBuilderService#msg, MessageBuilderService#handleUserMessage close() Close the channel. Source: Channel.js, line 64 × Search results Close "},"JoiningPeer.html":{"id":"JoiningPeer.html","title":"Class: JoiningPeer","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Class: JoiningPeer JoiningPeer This class represents a temporary state of a peer, while he is about to join the web channel. During the joining process every peer in the web channel and the joining peer have an instance of this class with the same id and intermediaryId attribute values. After the joining process has been finished regardless of success, these instances will be deleted. new JoiningPeer() Source: JoiningPeer.js, line 8 Members id :string The joining peer id. Type: string Source: JoiningPeer.js, line 15 intermediaryId :string The id of the peer who invited the joining peer to the web channel. It is a member of the web channel and called an intermediary peer between the joining peer and the web channel. The same value for all instances. Type: string Source: JoiningPeer.js, line 24 intermediaryChannel :Channel The channel between the joining peer and intermediary peer. It is null for every peer, but the joining and intermediary peers. Type: Channel Source: JoiningPeer.js, line 32 channelsToAdd :Array.&lt;Channel&gt; This attribute is proper to each peer. Array of channels which will be added to the current peer once the joining peer become the member of the web channel. Type: Array.&lt;Channel&gt; Source: JoiningPeer.js, line 41 channelsToRemove :Array.&lt;Channel&gt; This attribute is proper to each peer. Array of channels which will be closed with the current peer once the joining peer become the member of the web channel. Type: Array.&lt;Channel&gt; Source: JoiningPeer.js, line 50 Methods toAddList(channel) Add channel to channelsToAdd array. Parameters: Name Type Description channel Channel Channel to add. Source: JoiningPeer.js, line 58 toRemoveList(channel) Add channel to channelsToRemove array Parameters: Name Type Description channel Channel Channel to add. Source: JoiningPeer.js, line 67 × Search results Close "},"WebChannelGate.html":{"id":"WebChannelGate.html","title":"Class: WebChannelGate","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Class: WebChannelGate WebChannelGate This class represents a door of the WebChannel for this peer. If the door is open, then clients can join the WebChannel through this peer, otherwise they cannot. new WebChannelGate(onClose) Parameters: Name Type Description onClose WebChannelGate~onClose close event handler Source: WebChannel.js, line 98 Members &lt;private&gt; door :external:WebSocket Web socket which holds the connection with the signaling server. Type: external:WebSocket Source: WebChannel.js, line 115 &lt;private&gt; accessData :WebChannel~AccessData Web socket which holds the connection with the signaling server. Type: WebChannel~AccessData Source: WebChannel.js, line 122 &lt;private&gt; onCloseHandler :WebChannelGate~onClose Close event handler. Type: WebChannelGate~onClose Source: WebChannel.js, line 129 Methods getAccessData() Get access data. Source: WebChannel.js, line 137 Returns: Returns access data if the door is opened and null if it closed Type WebChannel~AccessData | null isOpen() Check if the door is opened or closed. Source: WebChannel.js, line 146 Returns: Returns true if the door is opened and false if it is closed Type boolean setOpen(door, accessData) Open the door. Parameters: Name Type Description door external:WebSocket Web socket to signalign server accessData WebChannel~AccessData Access data to join the *WebChannel Source: WebChannel.js, line 156 close() Close the door if it is open and do nothing if it is closed already. Source: WebChannel.js, line 165 Type Definitions AccessData Type: Object Properties: Name Type Description key string The unique key to join the WebChannel url string Signaling server url Source: WebChannel.js, line 100 × Search results Close "},"WebChannel.html":{"id":"WebChannel.html","title":"Class: WebChannel","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Class: WebChannel WebChannel This class is an API starting point. It represents a group of collaborators also called peers. Each peer can send/receive broadcast as well as personal messages. Every peer in the WebChannel can invite another person to join the WebChannel and he also possess enough information to be able to add it preserving the current WebChannel structure (network topology). new WebChannel( [options]) WebChannel constructor. WebChannel can be parameterized in terms of network topology and connector technology (WebRTC or WebSocket. Currently WebRTC is only available). Parameters: Name Type Argument Description options Object &lt;optional&gt; WebChannel configuration. Properties Name Type Argument Default Description topology string &lt;optional&gt; FULLY_CONNECTED Defines the network topology. connector string &lt;optional&gt; WEBRTC Determines the connection technology to use for build WebChannel. Source: WebChannel.js, line 180 Members &lt;private&gt; channels :external:Set Channels through which this peer is connected with other peers. This attribute depends on the WebChannel topology. E. g. in fully connected WebChannel you are connected to each other peer in the group, however in the star structure this attribute contains only the connection to the central peer. Type: external:Set Source: WebChannel.js, line 217 &lt;private&gt; onJoin This event handler is used to resolve Promise in WebChannel#join. Source: WebChannel.js, line 224 &lt;private&gt; joiningPeers :external:Set Set of joining peers. Type: external:Set Source: WebChannel.js, line 231 &lt;private&gt; connectWithRequests :external:Map Map of requests which is used to resolve Promise during joining peer process. Type: external:Map Source: WebChannel.js, line 239 &lt;private&gt; topology :string WebChannel topology. Type: string Source: WebChannel.js, line 246 &lt;private&gt; peerNb :number Total peer number in the WebChannel. Type: number Source: WebChannel.js, line 253 &lt;private&gt; pingTime :number Type: number Source: WebChannel.js, line 259 &lt;private&gt; gate :WebChannelGate The WebChannel gate. Type: WebChannelGate Source: WebChannel.js, line 266 &lt;readonly&gt; id Unique identifier of this WebChannel. The same for all peers. Source: WebChannel.js, line 272 &lt;readonly&gt; myId Unique peer identifier of you in this WebChannel. After each join function call this id will change, because it is up to the WebChannel to assign it when you join. Source: WebChannel.js, line 280 Methods onJoining(id) Is the event handler called when a new peer has joined the WebChannel. Parameters: Name Type Description id number Id of the joined peer Source: WebChannel.js, line 286 onMessage(id, data, isBroadcast) Is the event handler called when a message is available on the WebChannel. Parameters: Name Type Description id number Id of the peer who sent this message data string | external:ArrayBufferView Message isBroadcast boolean It is true if the message is sent via send method and false if it is sent via sendTo method Source: WebChannel.js, line 296 onLeaving(id) Is the event handler called when a peer hes left the WebChannel. Parameters: Name Type Description id number Id of the peer who has left Source: WebChannel.js, line 302 onClose(id) Is the event handler called when the WebChannel has been closed. Parameters: Name Type Description id external:CloseEvent Close event object Source: WebChannel.js, line 308 openForJoining( [options]) Enable other peers to join the WebChannel with your help as an intermediary peer. Parameters: Name Type Argument Description options Object &lt;optional&gt; Any available connection service options Source: WebChannel.js, line 318 Returns: It is resolved once the WebChannel is open. The callback function take a parameter of type WebChannel~AccessData. Type Promise closeForJoining() Prevent clients to join the WebChannel even if they possesses a key. Source: WebChannel.js, line 354 isOpen() If the WebChannel is open, the clients can join it through you, otherwise it is not possible. Source: WebChannel.js, line 363 Returns: True if the WebChannel is open, false otherwise Type boolean join(key [, options]) Join the WebChannel. Parameters: Name Type Argument Description key string The key provided by one of the WebChannel members. options type &lt;optional&gt; Any available connection service options. Source: WebChannel.js, line 373 Returns: It resolves once you became a WebChannel member. Type Promise leave() Leave the WebChannel. No longer can receive and send messages to the group. Source: WebChannel.js, line 387 send(data) Send the message to all WebChannel members. Parameters: Name Type Description data string | external:ArrayBufferView Message Source: WebChannel.js, line 403 sendTo(id, data) Send the message to a particular peer in the WebChannel. Parameters: Name Type Description id number Id of the recipient peer data string | external:ArrayBufferView Message Source: WebChannel.js, line 416 getAccess() Get the data which should be provided to all clients who must join the WebChannel. It is the same data which WebChannel#openForJoining callback function provides. Source: WebChannel.js, line 431 Returns: Data to join the WebChannel or null is the WebChannel is closed Type WebChannel~AccessData | null ping() Get the ping of the WebChannel. It is an amount in milliseconds which corresponds to the longest ping to each WebChannel member. Source: WebChannel.js, line 440 Returns: Type Promise &lt;private&gt; sendSrvMsg(serviceName, recepient [, msg]) Send a message to a service of the same peer, joining peer or any peer in the WebChannel. Parameters: Name Type Argument Default Description serviceName string Service name. recepient string Identifier of recepient peer id. msg Object &lt;optional&gt; {} Message to send. Source: WebChannel.js, line 465 &lt;private&gt; onChannelMessage(channel, data) Message event handler (WebChannel mediator). All messages arrive here first. Parameters: Name Type Description channel Channel The channel the message came from data external:ArrayBuffer Message Source: WebChannel.js, line 506 &lt;private&gt; onChannelError(evt) Error event handler for each Channel in the WebChannel. Parameters: Name Type Description evt external:Event Event Source: WebChannel.js, line 583 &lt;private&gt; onChannelClose(closeEvt) Close event handler for each Channel in the WebChannel. Parameters: Name Type Description closeEvt external:CloseEvent Close event Source: WebChannel.js, line 592 &lt;private&gt; initChannel(ch, isInitiator [, id]) Initialize channel. The Channel object is a facade for WebSocket and RTCDataChannel. Parameters: Name Type Argument Description ch external:WebSocket | external:RTCDataChannel Channel to initialize isInitiator boolean Equals to true if this peer is an initiator in the channel establishment, false otherwise id number &lt;optional&gt; Assign an id to this channel. It would be generated if not provided Source: WebChannel.js, line 613 Returns: Resolved once the channel is initialized on both sides Type Promise &lt;private&gt; joinSuccess(id) Function to be executed on each peer once the joining peer has joined the WebChannel Parameters: Name Type Description id number Identifier of the recently joined peer Source: WebChannel.js, line 640 &lt;private&gt; getJoiningPeer(id) Get joining peer by his id. Parameters: Name Type Description id number Peer id Source: WebChannel.js, line 655 Throws: Will throws an error if the peer could not be found &lt;private&gt; getJoiningPeers() Get all joining peers. Source: WebChannel.js, line 672 Returns: Joining peers Type external:Set &lt;private&gt; addJoiningPeer(jpId, intermediaryId [, intermediaryChannel]) Add joining peer. Parameters: Name Type Argument Description jpId number Joining peer id intermediaryId number The id of the peer through whom the joining peer joins the WebChannel intermediaryChannel Channel &lt;optional&gt; Intermediary channel bitween the joining peer and his intermediary peer Source: WebChannel.js, line 686 Returns: Just added joining peer Type JoiningPeer &lt;private&gt; removeJoiningPeer(jpId) Remove joining peer from the joining peer list if he exists. It is done when the joining peer finished the joining process succesfully or not. Parameters: Name Type Description jpId number Joining peer id Source: WebChannel.js, line 704 &lt;private&gt; isJoining() Check whether this peer is about to join the WebChannel. Source: WebChannel.js, line 716 Returns: True if this peer is joining the WebChannel and false otherwise Type boolean &lt;private&gt; hasJoiningPeer(jpId) Verify if this peer knows about specific joining peer. Parameters: Name Type Description jpId number Joining peer id Source: WebChannel.js, line 731 Returns: True if the peer is present, false if not. Type boolean &lt;private&gt; generateKey() Generate random key which will be used to join the WebChannel. Source: WebChannel.js, line 745 Returns: Generated key Type string &lt;private&gt; generateId() Generate random id for a WebChannel or a new peer. Source: WebChannel.js, line 763 Returns: Generated id Type number Type Definitions AccessData When the WebChannel is open, any clients should you this data to join the WebChannel. Type: Object Properties: Name Type Description key string The unique key to join the WebChannel url string Signaling server url Source: WebChannel.js, line 182 × Search results Close "},"external-JSON.html":{"id":"external-JSON.html","title":"External: JSON","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: JSON JSON Source: index.js, line 5 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON × Search results Close "},"external-Error.html":{"id":"external-Error.html","title":"External: Error","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: Error Error Source: index.js, line 9 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Error × Search results Close "},"external-RTCPeerConnection.html":{"id":"external-RTCPeerConnection.html","title":"External: RTCPeerConnection","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: RTCPeerConnection RTCPeerConnection Source: index.js, line 13 See: https://developer.mozilla.org/en/docs/Web/API/RTCPeerConnection × Search results Close "},"external-RTCSessionDescription.html":{"id":"external-RTCSessionDescription.html","title":"External: RTCSessionDescription","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: RTCSessionDescription RTCSessionDescription Source: index.js, line 17 See: https://developer.mozilla.org/en/docs/Web/API/RTCSessionDescription × Search results Close "},"external-RTCDataChannel.html":{"id":"external-RTCDataChannel.html","title":"External: RTCDataChannel","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: RTCDataChannel RTCDataChannel Source: index.js, line 21 See: https://developer.mozilla.org/en/docs/Web/API/RTCDataChannel × Search results Close "},"external-RTCIceCandidate.html":{"id":"external-RTCIceCandidate.html","title":"External: RTCIceCandidate","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: RTCIceCandidate RTCIceCandidate Source: index.js, line 25 See: https://developer.mozilla.org/en/docs/Web/API/RTCIceCandidate × Search results Close "},"external-RTCPeerConnectionIceEvent.html":{"id":"external-RTCPeerConnectionIceEvent.html","title":"External: RTCPeerConnectionIceEvent","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: RTCPeerConnectionIceEvent RTCPeerConnectionIceEvent Source: index.js, line 29 See: https://developer.mozilla.org/en/docs/Web/API/RTCPeerConnectionIceEvent × Search results Close "},"external-CloseEvent.html":{"id":"external-CloseEvent.html","title":"External: CloseEvent","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: CloseEvent CloseEvent Source: index.js, line 33 See: https://developer.mozilla.org/en/docs/Web/API/CloseEvent/CloseEvent × Search results Close "},"external-WebSocket.html":{"id":"external-WebSocket.html","title":"External: WebSocket","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: WebSocket WebSocket Source: index.js, line 37 See: https://developer.mozilla.org/en/docs/Web/API/WebSocket × Search results Close "},"external-Set.html":{"id":"external-Set.html","title":"External: Set","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: Set Set Source: index.js, line 41 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set × Search results Close "},"external-Map.html":{"id":"external-Map.html","title":"External: Map","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: Map Map Source: index.js, line 45 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Map × Search results Close "},"external-ArrayBufferView.html":{"id":"external-ArrayBufferView.html","title":"External: ArrayBufferView","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: ArrayBufferView ArrayBufferView Source: index.js, line 49 See: https://developer.mozilla.org/en/docs/Web/API/ArrayBufferView × Search results Close "},"external-ArrayBuffer.html":{"id":"external-ArrayBuffer.html","title":"External: ArrayBuffer","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: ArrayBuffer ArrayBuffer Source: index.js, line 53 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer × Search results Close "},"external-String.html":{"id":"external-String.html","title":"External: String","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: String String Source: index.js, line 57 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String × Search results Close "},"external-Int8Array.html":{"id":"external-Int8Array.html","title":"External: Int8Array","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: Int8Array Int8Array Source: index.js, line 61 See: developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Int8Array × Search results Close "},"external-Uint8Array.html":{"id":"external-Uint8Array.html","title":"External: Uint8Array","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: Uint8Array Uint8Array Source: index.js, line 65 See: developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array × Search results Close "},"external-Uint8ClampedArray.html":{"id":"external-Uint8ClampedArray.html","title":"External: Uint8ClampedArray","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: Uint8ClampedArray Uint8ClampedArray Source: index.js, line 69 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray × Search results Close "},"external-Int16Array.html":{"id":"external-Int16Array.html","title":"External: Int16Array","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: Int16Array Int16Array Source: index.js, line 73 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Int16Array × Search results Close "},"external-Uint16Array.html":{"id":"external-Uint16Array.html","title":"External: Uint16Array","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: Uint16Array Uint16Array Source: index.js, line 77 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array × Search results Close "},"external-Int32Array.html":{"id":"external-Int32Array.html","title":"External: Int32Array","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: Int32Array Int32Array Source: index.js, line 81 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Int32Array × Search results Close "},"external-Uint32Array.html":{"id":"external-Uint32Array.html","title":"External: Uint32Array","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: Uint32Array Uint32Array Source: index.js, line 85 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array × Search results Close "},"external-Float32Array.html":{"id":"external-Float32Array.html","title":"External: Float32Array","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: Float32Array Float32Array Source: index.js, line 89 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Float32Array × Search results Close "},"external-Float64Array.html":{"id":"external-Float64Array.html","title":"External: Float64Array","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: Float64Array Float64Array Source: index.js, line 93 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Float64Array × Search results Close "},"external-DataView.html":{"id":"external-DataView.html","title":"External: DataView","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView External: DataView DataView Source: index.js, line 97 See: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/DataView × Search results Close "},"WebRTCService.html":{"id":"WebRTCService.html","title":"Class: WebRTCService","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Class: WebRTCService WebRTCService Service class responsible to establish connections between peers via RTCDataChannel. new WebRTCService( [options]) WebRTCService constructor. Parameters: Name Type Argument Description options Object &lt;optional&gt; This service options. Properties Name Type Argument Default Description signaling Object &lt;optional&gt; 'wws://sigver-coastteam.rhcloud.com:8000' Signaling server URL. iceServers Array.&lt;Object&gt; &lt;optional&gt; [{urls: 'stun:23.21.150.121'},{urls: 'stun:stun.l.google.com:19302'},{urls: 'turn:numb.viagenie.ca', credential: 'webrtcdemo', username: 'louis%40mozilla.com'}] WebRTC options to setup which STUN and TURN servers to be used. Source: service/channelBuilder/WebRTCService.js, line 112 See: external:RTCPeerConnection Extends module:channelBuilder~ChannelBuilderInterface Methods createPeerConnectionAndOffer(onCandidate, sendOffer, onChannel) Creates a peer connection and generates an SDP offer. Parameters: Name Type Description onCandidate WebRTCService~onCandidate Ice candidate event handler. sendOffer WebRTCService~onSDP Session description event handler. onChannel WebRTCService~onChannel Handler event when the data channel is ready. Source: service/channelBuilder/WebRTCService.js, line 304 Returns: Resolved when the offer has been succesfully created, set as local description and sent to the peer. Type Promise createPeerConnectionAndAnswer(onCandidate, sendOffer, onChannel, offer) Creates a peer connection and generates an SDP answer. Parameters: Name Type Description onCandidate WebRTCService~onCandidate Ice candidate event handler. sendOffer WebRTCService~onSDP Session description event handler. onChannel WebRTCService~onChannel Handler event when the data channel is ready. offer Object Offer received from a peer. Source: service/channelBuilder/WebRTCService.js, line 334 Returns: Resolved when the offer has been succesfully created, set as local description and sent to the peer. Type Promise &lt;private&gt; createPeerConnection(onCandidate) Creates an instance of RTCPeerConnection and sets onicecandidate event handler. Parameters: Name Type Description onCandidate WebRTCService~onCandidate Ice candidate event handler. Source: service/channelBuilder/WebRTCService.js, line 376 Returns: Peer connection. Type external:RTCPeerConnection &lt;private&gt; createIceCandidate(candidate) Creates an instance of RTCIceCandidate. Parameters: Name Type Description candidate Object Candidate object created in WebRTCService#createPeerConnection. Properties Name Type Description candidate sdpMLineIndex Source: service/channelBuilder/WebRTCService.js, line 400 Returns: Ice candidate. Type external:RTCIceCandidate &lt;private&gt; createSessionDescription(sd) Creates an instance of RTCSessionDescription. Parameters: Name Type Description sd Object An offer or an answer created by WebRTC API. Properties Name Type Description type sdp Source: service/channelBuilder/WebRTCService.js, line 413 Returns: Session description. Type external:RTCSessionDescription &lt;abstract&gt; open(key, onChannel [, options]) Enables other clients to establish a connection with you. Parameters: Name Type Argument Description key string The unique identifier which has to be passed to the peers who need to connect to you. onChannel module:channelBuilder~ChannelBuilderInterface~onChannelCallback Callback function to execute once the connection has been established. options Object &lt;optional&gt; Any other options which depend on the service implementation. Inherited From: module:channelBuilder~ChannelBuilderInterface#open Overrides: module:channelBuilder~ChannelBuilderInterface#open Source: service/channelBuilder/channelBuilder.js, line 52 Returns: Once resolved, provide an Object with key and url attributes to be passed to module:channelBuilder~ChannelBuilderInterface#join function. It is rejected if an error occured. Type Promise &lt;abstract&gt; join(key [, options]) Connects you with the peer who provided the key. Parameters: Name Type Argument Description key string A key obtained from the peer who executed module:channelBuilder~ChannelBuilderInterface#open function. options Object &lt;optional&gt; Any other options which depend on the implementation. Inherited From: module:channelBuilder~ChannelBuilderInterface#join Overrides: module:channelBuilder~ChannelBuilderInterface#join Source: service/channelBuilder/channelBuilder.js, line 65 Returns: It is resolved when the connection is established, otherwise it is rejected. Type Promise &lt;abstract&gt; connectMeTo(wc, id) Establish a connection between you and another peer (including joining peer) via web channel. Parameters: Name Type Description wc WebChannel Web Channel through which the connection will be established. id string Peer id with whom you will be connected. Inherited From: module:channelBuilder~ChannelBuilderInterface#connectMeTo Overrides: module:channelBuilder~ChannelBuilderInterface#connectMeTo Source: service/channelBuilder/channelBuilder.js, line 77 Returns: Resolved once the connection has been established, rejected otherwise. Type Promise Type Definitions onCandidate(evt) Ice candidate event handler. Parameters: Name Type Description evt external:RTCPeerConnectionIceEvent Event. Source: service/channelBuilder/WebRTCService.js, line 3 onSDP(evt) Session description event handler. Parameters: Name Type Description evt external:RTCPeerConnectionIceEvent Event. Source: service/channelBuilder/WebRTCService.js, line 10 onChannel(evt) Data channel event handler. Parameters: Name Type Description evt external:RTCPeerConnectionIceEvent Event. Source: service/channelBuilder/WebRTCService.js, line 17 × Search results Close "},"RTCPendingConnections.html":{"id":"RTCPendingConnections.html","title":"Class: RTCPendingConnections","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Class: RTCPendingConnections RTCPendingConnections The goal of this class is to prevent the error when adding an ice candidate before the remote description has been set. new RTCPendingConnections() Source: service/channelBuilder/WebRTCService.js, line 28 Methods add(id) Prepares pending connection for the specified peer only if it has not been added already. Parameters: Name Type Description id string Peer id Source: service/channelBuilder/WebRTCService.js, line 38 remove(id) Remove a pending connection from the Map. Usually when the connection has already been established and there is now interest to hold this reference. Parameters: Name Type Description id string Peer id. Source: service/channelBuilder/WebRTCService.js, line 62 getPC(id) Returns RTCPeerConnection object for the provided peer id. Parameters: Name Type Description id string Peer id. Source: service/channelBuilder/WebRTCService.js, line 72 Returns: Peer connection. Type external:RTCPeerConnection setPC(id, pc) Updates RTCPeerConnection reference for the provided peer id. Parameters: Name Type Description id string Peer id. pc external:RTCPeerConnection Peer connection. Source: service/channelBuilder/WebRTCService.js, line 82 addIceCandidate(id, candidate) When the remote description is set, it will add the ice candidate to the peer connection of specified peer. Parameters: Name Type Description id string Peer id. candidate external:RTCIceCandidate Ice candidate. Source: service/channelBuilder/WebRTCService.js, line 94 Returns: Resolved once the ice candidate has been succesfully added. Type Promise × Search results Close "},"module-channelBuilder.html":{"id":"module-channelBuilder.html","title":"Module: channelBuilder","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Module: channelBuilder Channel Builder module is responsible to create a connection between two peers. Source: service/channelBuilder/channelBuilder.js, line 2 See: Channel Members &lt;static&gt; ChannelBuilderInterface Source: service/channelBuilder/channelBuilder.js, line 84 See: module:channelBuilder~ChannelBuilderInterface Type Definitions onChannelCallback(channel) On channel callback for module:channelBuilder~ChannelBuilderInterface#open function. Parameters: Name Type Description channel Channel A new channel. Source: service/channelBuilder/channelBuilder.js, line 9 initChannel(ch, id) Call back to initialize the channel. It should be executed on both peer sides during connection establishment to assure that both channels would be ready to be used in the web channel. Parameters: Name Type Description ch Channel Channel. id string Unique channel identifier. Source: service/channelBuilder/channelBuilder.js, line 17 × Search results Close "},"module-channelBuilder-ChannelBuilderInterface.html":{"id":"module-channelBuilder-ChannelBuilderInterface.html","title":"Interface: ChannelBuilderInterface","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Interface: ChannelBuilderInterface channelBuilder~ ChannelBuilderInterface Interface to be implemented by each connection service. Source: service/channelBuilder/channelBuilder.js, line 33 Extends module:service~ServiceInterface Members name Service name which corresponds to its class name. Inherited From: module:service~ServiceInterface#name Source: service/service.js, line 24 Methods &lt;abstract&gt; open(key, onChannel [, options]) Enables other clients to establish a connection with you. Parameters: Name Type Argument Description key string The unique identifier which has to be passed to the peers who need to connect to you. onChannel module:channelBuilder~ChannelBuilderInterface~onChannelCallback Callback function to execute once the connection has been established. options Object &lt;optional&gt; Any other options which depend on the service implementation. Source: service/channelBuilder/channelBuilder.js, line 52 Returns: Once resolved, provide an Object with key and url attributes to be passed to module:channelBuilder~ChannelBuilderInterface#join function. It is rejected if an error occured. Type Promise &lt;abstract&gt; join(key [, options]) Connects you with the peer who provided the key. Parameters: Name Type Argument Description key string A key obtained from the peer who executed module:channelBuilder~ChannelBuilderInterface#open function. options Object &lt;optional&gt; Any other options which depend on the implementation. Source: service/channelBuilder/channelBuilder.js, line 65 Returns: It is resolved when the connection is established, otherwise it is rejected. Type Promise &lt;abstract&gt; connectMeTo(wc, id) Establish a connection between you and another peer (including joining peer) via web channel. Parameters: Name Type Description wc WebChannel Web Channel through which the connection will be established. id string Peer id with whom you will be connected. Source: service/channelBuilder/channelBuilder.js, line 77 Returns: Resolved once the connection has been established, rejected otherwise. Type Promise × Search results Close "},"module-messageBuilder.html":{"id":"module-messageBuilder.html","title":"Module: messageBuilder","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Module: messageBuilder Message builder module is responsible to build messages to send them over the WebChannel and treat messages received by the WebChannel. It also manage big messages (more then 16ko) sent by users. Internal messages are always less 16ko. Source: service/messageBuilder.js, line 1 Classes MessageBuilderService Buffer Members &lt;inner, constant&gt; MAX_MSG_SIZE :number Maximum message size sent over Channel. Type: number Source: service/messageBuilder.js, line 15 &lt;inner, constant&gt; MAX_USER_MSG_SIZE :number Maximum user message size sent over Channel. Is meant without metadata. Type: number Source: service/messageBuilder.js, line 21 &lt;inner, constant&gt; USER_MSG_OFFSET :number User message offset in the array buffer. All data before are metadata. Type: number Source: service/messageBuilder.js, line 27 &lt;inner, constant&gt; HEADER_END_OFFSET :number First index in the array buffer after header (which is the part of metadata). Type: number Source: service/messageBuilder.js, line 33 &lt;inner, constant&gt; MAX_MSG_ID_SIZE :number Maximum message id number. Type: number Source: service/messageBuilder.js, line 39 &lt;inner, constant&gt; ARRAY_BUFFER_TYPE :number User allowed message type: external:ArrayBuffer Type: number Source: service/messageBuilder.js, line 45 &lt;inner, constant&gt; U_INT_8_ARRAY_TYPE :number User allowed message type: external:Uint8Array Type: number Source: service/messageBuilder.js, line 51 &lt;inner, constant&gt; STRING_TYPE :number User allowed message type: external:String Type: number Source: service/messageBuilder.js, line 57 &lt;inner, constant&gt; INT_8_ARRAY_TYPE :number User allowed message type: external:Int8Array Type: number Source: service/messageBuilder.js, line 63 &lt;inner, constant&gt; U_INT_8_CLAMPED_ARRAY_TYPE :number User allowed message type: external:Uint8ClampedArray Type: number Source: service/messageBuilder.js, line 69 &lt;inner, constant&gt; INT_16_ARRAY_TYPE :number User allowed message type: external:Int16Array Type: number Source: service/messageBuilder.js, line 75 &lt;inner, constant&gt; U_INT_16_ARRAY_TYPE :number User allowed message type: external:Uint16Array Type: number Source: service/messageBuilder.js, line 81 &lt;inner, constant&gt; INT_32_ARRAY_TYPE :number User allowed message type: external:Int32Array Type: number Source: service/messageBuilder.js, line 87 &lt;inner, constant&gt; U_INT_32_ARRAY_TYPE :number User allowed message type: external:Uint32Array Type: number Source: service/messageBuilder.js, line 93 &lt;inner, constant&gt; FLOAT_32_ARRAY_TYPE :number User allowed message type: external:Float32Array Type: number Source: service/messageBuilder.js, line 99 &lt;inner, constant&gt; FLOAT_64_ARRAY_TYPE :number User allowed message type: external:Float64Array Type: number Source: service/messageBuilder.js, line 105 &lt;inner, constant&gt; DATA_VIEW_TYPE :number User allowed message type: external:DataView Type: number Source: service/messageBuilder.js, line 111 &lt;inner, constant&gt; buffers Buffer for big user messages. Source: service/messageBuilder.js, line 116 × Search results Close "},"module-messageBuilder-MessageBuilderService.html":{"id":"module-messageBuilder-MessageBuilderService.html","title":"Class: MessageBuilderService","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Class: MessageBuilderService messageBuilder~ MessageBuilderService Message builder service class. new MessageBuilderService() Source: service/messageBuilder.js, line 121 Methods handleUserMessage(data, senderId, recipientId, action, isBroadcast) Prepare user message to be sent over the WebChannel Parameters: Name Type Description data external:ArrayBuffer | external:Uint8Array | external:String | external:Int8Array | external:Uint8ClampedArray | external:Int16Array | external:Uint16Array | external:Int32Array | external:Uint32Array | external:Float32Array | external:Float64Array | external:DataView Message to be sent senderId number Id of the peer who sends this message recipientId number Id of the recipient peer action MessageBuilderService~Send Send callback executed for each data chunk if the message is too big isBroadcast boolean Equals to true if this message would be sent to all WebChannel members and false if only to one member Source: service/messageBuilder.js, line 164 msg(code [, data]) Build a message which can be then sent trough the Channel. Parameters: Name Type Argument Default Description code number One of the internal message type code (e.g. USER_DATA) data Object &lt;optional&gt; {} Message. Could be empty if the code is enough Source: service/messageBuilder.js, line 215 Returns: Built message Type external:ArrayBuffer readUserMessage(wcId, senderId, data, action) Read user message which was prepared by another peer with MessageBuilderService#handleUserMessage and sent. Parameters: Name Type Description wcId number WebChannel identifier senderId number Id of the peer who sent this message data external:ArrayBuffer Message action MessageBuilderService~Receive Callback when the message is ready Source: service/messageBuilder.js, line 233 readInternalMessage(data) Read internal Netflux message. Parameters: Name Type Description data external:ArrayBuffer Message Source: service/messageBuilder.js, line 267 Returns: Type Object readHeader(data) Extract header from the message. Each user message has a header which is a part of the message metadata. TODO: add header also to the internal messages. Parameters: Name Type Description data external:ArrayBuffer Whole message Source: service/messageBuilder.js, line 281 Returns: Type MessageBuilderService~Header &lt;private&gt; writeHeader(code, senderId, recipientId, dataSize) Create an ArrayBuffer and fill in the header. Parameters: Name Type Description code number Message type code senderId number Sender peer id recipientId number Recipient peer id dataSize number Message size in bytes Source: service/messageBuilder.js, line 299 Returns: Data view with initialized header Type external:DataView &lt;private&gt; extractUserData(buffer, type) Netflux sends data in ArrayBuffer, but the user can send data in different types. This function retrieve the inital message sent by the user. Parameters: Name Type Description buffer external:ArrayBuffer Message as it was received by the WebChannel type number Message type as it was defined by the user Source: service/messageBuilder.js, line 319 Returns: Initial user message Type external:ArrayBuffer | external:Uint8Array | external:String | external:Int8Array | external:Uint8ClampedArray | external:Int16Array | external:Uint16Array | external:Int32Array | external:Uint32Array | external:Float32Array | external:Float64Array | external:DataView &lt;private&gt; userDataToType(data) Identify the user message type. Parameters: Name Type Description data external:ArrayBuffer | external:Uint8Array | external:String | external:Int8Array | external:Uint8ClampedArray | external:Int16Array | external:Uint16Array | external:Int32Array | external:Uint32Array | external:Float32Array | external:Float64Array | external:DataView User message Source: service/messageBuilder.js, line 357 Returns: User message type Type number &lt;private&gt; getBuffer(wcId, peerId, msgId) Get the buffer. Parameters: Name Type Description wcId number WebChannel id peerId number Peer id msgId number Message id Source: service/messageBuilder.js, line 404 Returns: Returns buffer if it was found and undefined if not Type Buffer | undefined &lt;private&gt; setBuffer(wcId, peerId, msgId, buffer) Add a new buffer to the buffer array. Parameters: Name Type Description wcId number WebChannel id peerId number Peer id msgId number Message id buffer Buffer buffer Source: service/messageBuilder.js, line 423 × Search results Close "},"module-messageBuilder-Buffer.html":{"id":"module-messageBuilder-Buffer.html","title":"Class: Buffer","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Class: Buffer messageBuilder~ Buffer Buffer class used when the user message exceeds the message size limit which may be sent over a Channel. Each buffer is identified by WebChannel id, peer id (who sends the big message) and message id (in case if the peer sends more then 1 big message at a time). new Buffer(fullDataSize, data, action) Parameters: Name Type Description fullDataSize number The total user message size data external:ArrayBuffer The first chunk of the user message action Buffer~onFullMessage Callback to be executed when all message chunks are received and thus the message is ready Source: service/messageBuilder.js, line 444 Methods add(data, chunkNb) Add a chunk of message to the buffer. Parameters: Name Type Description data external:ArrayBuffer Message chunk chunkNb number Number of the chunk Source: service/messageBuilder.js, line 470 × Search results Close "},"module-service.html":{"id":"module-service.html","title":"Module: service","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Module: service Service module includes module:channelBuilder, module:webChannelManager and module:messageBuilder. Services are substitutable stateless objects. Each service is identified by its class name and some of them can receive messages via WebChannel sent by another service. Source: service/service.js, line 1 See: module:channelBuilder module:webChannelManager module:messageBuilder Members &lt;static&gt; ServiceInterface Source: service/service.js, line 31 See: module:service~ServiceInterface × Search results Close "},"module-service-ServiceInterface.html":{"id":"module-service-ServiceInterface.html","title":"Interface: ServiceInterface","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Interface: ServiceInterface service~ ServiceInterface Each service must implement this interface. Source: service/service.js, line 18 Members name Service name which corresponds to its class name. Source: service/service.js, line 24 × Search results Close "},"FullyConnectedService.html":{"id":"FullyConnectedService.html","title":"Class: FullyConnectedService","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Class: FullyConnectedService FullyConnectedService Fully connected web channel manager. Implements fully connected topology network, when each peer is connected to each other. new FullyConnectedService() Source: service/webChannelManager/FullyConnectedService.js, line 9 Extends module:webChannelManager~WebChannelManagerInterface Methods connectWith(wc, id, jpId, peerIds) Send a request to a peer asking him to establish a connection with some peers. This function is used when a new peer is joining the WebChannel. The request can be sent to the peer who is joining as well as other peers who are already members of the WebChannel. Parameters: Name Type Description wc WebChannel The Web Channel. id string Id of the peer who will receive this request. jpId string Joining peer id (it is possible that id=jpId). peerIds Array.&lt;string&gt; Ids of peers with whom id peer must established connections. Inherited From: module:webChannelManager~WebChannelManagerInterface#connectWith Source: service/webChannelManager/webChannelManager.js, line 127 Returns: Is resolved once some of the connections could be established. It is rejected when an error occured. Type Promise &lt;abstract&gt; add(ch) Adds a new peer into Web Channel. Parameters: Name Type Description ch Channel Channel to be added (it should has the webChannel property). Inherited From: module:webChannelManager~WebChannelManagerInterface#add Overrides: module:webChannelManager~WebChannelManagerInterface#add Source: service/webChannelManager/webChannelManager.js, line 198 Returns: Resolved once the channel has been succesfully added, rejected otherwise. Type Promise &lt;abstract&gt; broadcast(wc, data) Send a message to all peers in Web Channel. Parameters: Name Type Description wc WebChannel Web Channel where the message will be propagated. data string Data in stringified JSON format to be send. Inherited From: module:webChannelManager~WebChannelManagerInterface#broadcast Overrides: module:webChannelManager~WebChannelManagerInterface#broadcast Source: service/webChannelManager/webChannelManager.js, line 209 &lt;abstract&gt; sendTo(id, wc, data) Send a message to a particular peer in Web Channel. Parameters: Name Type Description id string Peer id. wc WebChannel Web Channel where the message will be propagated. data string Data in stringified JSON format to be send. Inherited From: module:webChannelManager~WebChannelManagerInterface#sendTo Overrides: module:webChannelManager~WebChannelManagerInterface#sendTo Source: service/webChannelManager/webChannelManager.js, line 221 &lt;abstract&gt; leave(wc) Leave Web Channel. Parameters: Name Type Description wc WebChannel Web Channel to leave. Inherited From: module:webChannelManager~WebChannelManagerInterface#leave Overrides: module:webChannelManager~WebChannelManagerInterface#leave Source: service/webChannelManager/webChannelManager.js, line 231 × Search results Close "},"module-webChannelManager.html":{"id":"module-webChannelManager.html","title":"Module: webChannelManager","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Module: webChannelManager Web Channel Manager module is a submodule of module:service and the main component of any Web Channel. It is responsible to preserve Web Channel structure intact (i.e. all peers have the same vision of the Web Channel). Among its duties are: Add a new peer into Web Channel. Remove a peer from Web Channel. Send a broadcast message. Send a message to a particular peer. Source: service/webChannelManager/webChannelManager.js, line 4 See: FullyConnectedService Members &lt;inner, constant&gt; CONNECT_WITH Connection service of the peer who received a message of this type should establish connection with one or several peers. Source: service/webChannelManager/webChannelManager.js, line 23 &lt;static&gt; WebChannelManagerInterface Source: service/webChannelManager/webChannelManager.js, line 238 See: module:webChannelManager~WebChannelManagerInterface × Search results Close "},"module-webChannelManager-WebChannelManagerInterface.html":{"id":"module-webChannelManager-WebChannelManagerInterface.html","title":"Interface: WebChannelManagerInterface","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Interface: WebChannelManagerInterface webChannelManager~ WebChannelManagerInterface Each Web Channel Manager Service must implement this interface. Source: service/webChannelManager/webChannelManager.js, line 34 Extends module:service~ServiceInterface Members name Service name which corresponds to its class name. Inherited From: module:service~ServiceInterface#name Source: service/service.js, line 24 Methods connectWith(wc, id, jpId, peerIds) Send a request to a peer asking him to establish a connection with some peers. This function is used when a new peer is joining the WebChannel. The request can be sent to the peer who is joining as well as other peers who are already members of the WebChannel. Parameters: Name Type Description wc WebChannel The Web Channel. id string Id of the peer who will receive this request. jpId string Joining peer id (it is possible that id=jpId). peerIds Array.&lt;string&gt; Ids of peers with whom id peer must established connections. Source: service/webChannelManager/webChannelManager.js, line 127 Returns: Is resolved once some of the connections could be established. It is rejected when an error occured. Type Promise &lt;abstract&gt; add(ch) Adds a new peer into Web Channel. Parameters: Name Type Description ch Channel Channel to be added (it should has the webChannel property). Source: service/webChannelManager/webChannelManager.js, line 198 Returns: Resolved once the channel has been succesfully added, rejected otherwise. Type Promise &lt;abstract&gt; broadcast(wc, data) Send a message to all peers in Web Channel. Parameters: Name Type Description wc WebChannel Web Channel where the message will be propagated. data string Data in stringified JSON format to be send. Source: service/webChannelManager/webChannelManager.js, line 209 &lt;abstract&gt; sendTo(id, wc, data) Send a message to a particular peer in Web Channel. Parameters: Name Type Description id string Peer id. wc WebChannel Web Channel where the message will be propagated. data string Data in stringified JSON format to be send. Source: service/webChannelManager/webChannelManager.js, line 221 &lt;abstract&gt; leave(wc) Leave Web Channel. Parameters: Name Type Description wc WebChannel Web Channel to leave. Source: service/webChannelManager/webChannelManager.js, line 231 × Search results Close "},"module-serviceProvider.html":{"id":"module-serviceProvider.html","title":"Module: serviceProvider","body":" Netflux v0.8.0 Modules channelBuildermessageBuilderservicewebChannelManagerserviceProvider Classes ChannelJoiningPeerWebChannelGateWebChannelRTCPendingConnectionsWebRTCServicemessageBuilder~MessageBuilderServicemessageBuilder~BufferFullyConnectedService Interfaces channelBuilder~ChannelBuilderInterfaceservice~ServiceInterfacewebChannelManager~WebChannelManagerInterface Global MAX_IDPING_TIMEOUTUSER_DATASERVICE_DATALEAVEJOIN_INITJOIN_NEW_MEMBERREMOVE_NEW_MEMBERJOIN_FINILIZEJOIN_SUCCESSINIT_CHANNEL_PONGPINGPONG Externals JSONErrorRTCPeerConnectionRTCSessionDescriptionRTCDataChannelRTCIceCandidateRTCPeerConnectionIceEventCloseEventWebSocketSetMapArrayBufferViewArrayBufferStringInt8ArrayUint8ArrayUint8ClampedArrayInt16ArrayUint16ArrayInt32ArrayUint32ArrayFloat32ArrayFloat64ArrayDataView Module: serviceProvider Service Provider module is a helper module for module:service. It is responsible to instantiate all services. This module must be used to get any service instance. Source: serviceProvider.js, line 4 Members &lt;inner, constant&gt; WEBRTC :string Constant used to get an instance of WebRTCService. Type: string Source: serviceProvider.js, line 15 &lt;inner, constant&gt; FULLY_CONNECTED :string Constant used to get an instance of FullyConnectedService. It is a singleton service. Type: string Source: serviceProvider.js, line 22 &lt;inner, constant&gt; MESSAGE_BUILDER :string Constant used to get an instance of MessageBuilderService. It is a singleton service. Type: string Source: serviceProvider.js, line 29 &lt;inner, constant&gt; services :string Contains services who are singletons. Type: string Source: serviceProvider.js, line 35 Methods &lt;inner&gt; provide(name [, options]) Provides the service instance specified by name. Parameters: Name Type Argument Description name module:serviceProvider.MESSAGE_BUILDER | module:serviceProvider.WEBRTC | module:serviceProvider.FULLY_CONNECTED The service name. options Object &lt;optional&gt; Any options that the service accepts. Source: serviceProvider.js, line 47 Throws: An error if the service name is unknown Returns: Service instance. Type module:service~ServiceInterface × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
